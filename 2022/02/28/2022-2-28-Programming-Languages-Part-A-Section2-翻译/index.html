<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Programming Languages Part A Section2 翻译 | Doraemonzzz</title><meta name="keywords" content="Coursera Programming Languages"><meta name="author" content="Doraemonzzz"><meta name="copyright" content="Doraemonzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这里对Section 2进行翻译。 课程主页： https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;programming-languages&#x2F;home B站搬运： https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1dL411j7L7">
<meta property="og:type" content="article">
<meta property="og:title" content="Programming Languages Part A Section2 翻译">
<meta property="og:url" content="http://www.doraemonzzz.com/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="Doraemonzzz">
<meta property="og:description" content="这里对Section 2进行翻译。 课程主页： https:&#x2F;&#x2F;www.coursera.org&#x2F;learn&#x2F;programming-languages&#x2F;home B站搬运： https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1dL411j7L7">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2022-02-28T01:16:00.000Z">
<meta property="article:modified_time" content="2022-03-13T02:48:36.632Z">
<meta property="article:author" content="Doraemonzzz">
<meta property="article:tag" content="Coursera Programming Languages">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="https://github.com/Doraemonzzz/md-photo/blob/master/%E5%A4%B4%E5%83%8F.jpg?raw=true"><link rel="canonical" href="http://www.doraemonzzz.com/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f00f37f957f0608abb8c571105456f0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-G-RE4B1LKRZD"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-G-RE4B1LKRZD');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离上次更新已经","messageNext":"天了，文章内容可能已经过时。"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Programming Languages Part A Section2 翻译',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-13 10:48:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/bilibili.css" media="defer" onload="this.media='all'"><meta name="google-site-verification" content="c4v-NmuUZRgl3cvtg9GKswryK1YLaPztd_5M-df5VNI" /><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Doraemonzzz" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/%E5%A4%B4%E5%83%8F.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">779</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-chart-pie"></i><span> 博客统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/charts/"><i class="fa-fw far fa-chart-bar"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/census/"><i class="fa-fw fas fa-chart-area"></i><span> 访问统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/top/"><i class="fa-fw fab fa-hotjar"></i><span> 阅读排行榜</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Doraemonzzz</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-chart-pie"></i><span> 博客统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/charts/"><i class="fa-fw far fa-chart-bar"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/census/"><i class="fa-fw fas fa-chart-area"></i><span> 访问统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/top/"><i class="fa-fw fab fa-hotjar"></i><span> 阅读排行榜</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Programming Languages Part A Section2 翻译</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-28T01:16:00.000Z" title="发表于 2022-02-28 09:16:00">2022-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-13T02:48:36.632Z" title="更新于 2022-03-13 10:48:36">2022-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Coursera-Programming-Languages/">Coursera Programming Languages</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/" data-flag-title="Programming Languages Part A Section2 翻译"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>这里对Section 2进行翻译。</p>
<p>课程主页：</p>
<p><a target="_blank" rel="noopener" href="https://www.coursera.org/learn/programming-languages/home">https://www.coursera.org/learn/programming-languages/home</a></p>
<p>B站搬运：</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1dL411j7L7">https://www.bilibili.com/video/BV1dL411j7L7</a></p>
<span id="more"></span>
<h1 id="Coursera编程语言课程-第2节总结"><a href="#Coursera编程语言课程-第2节总结" class="headerlink" title="Coursera编程语言课程 第2节总结"></a>Coursera编程语言课程 第2节总结</h1><p>标准说明：本总结涵盖的材料与课堂视频以及随视频发布的材料（幻灯片、代码）大致相同。它有助于以叙述的方式阅读材料，并将整个课程部分的材料放在一份文件中，特别是在以后复习材料时。请在讨论板上报告这些笔记中的错误。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>构建新类型的概念性方法</li>
<li>记录：另一种处理”Each-of”类型的方法</li>
<li>按名称与按位置，法糖，以及关于元组的真相 </li>
<li>数据类型绑定：我们自己的“One-of”类型</li>
<li>ML如何不提供对数据类型值的访问</li>
<li>ML如何提供对数据类型值的访问：Case表达式</li>
<li>有用的”One-of”类型的例子</li>
<li>到目前为止，数据类型绑定和Case表达式的精确介绍</li>
<li>类型同义词</li>
<li>Lists和Options是数据类型</li>
<li>多态数据类型</li>
<li>Each-of类型的模式匹配：关于变量绑定的真相</li>
<li>题外话：类型推理</li>
<li>题外话：多态类型和等价类型</li>
<li>嵌套模式</li>
<li>嵌套模式的有用例子</li>
<li>可选：函数绑定中的多种情况 </li>
<li>异常</li>
<li>尾递归和累加器.</li>
<li>尾递归的更多例子</li>
<li>尾部位置的精确定义</li>
</ul>
<h2 id="构建新类型的概念性方法"><a href="#构建新类型的概念性方法" class="headerlink" title="构建新类型的概念性方法"></a>构建新类型的概念性方法</h2><p>编程语言有基本类型，如<code>int</code>、<code>bool</code>、<code>unit</code>和<code>component</code>类型，这些类型在其定义中包含其他类型。我们已经看到了在ML中生成复合类型的方法，即使用元组类型、列表类型和选项类型。我们将很快学习新的方法来创建更灵活的复合类型，并为我们的新类型命名。要创建复合类型，实际上只有三个基本构建块。任何像样的编程语言都以某种方式提供这些构建块：</p>
<ul>
<li>“Each-of”：复合类型<code>t</code>描述了包含<code>t1</code>, <code>t2</code>, …,<code>tn</code>类型的每个值的值。</li>
<li>“One-of”：复合类型<code>t</code>描述了包含<code>t1</code>, <code>t2</code>, …,<code>tn</code>类型的某个值的值。</li>
<li>“Self-reference”：复合类型<code>t</code>可以在其定义中引用自身，以描述递归数据结构，如列表和树。</li>
</ul>
<p>Each-of类型都是大多数程序员最熟悉的。元组就是一个例子：<code>int * bool</code>描述包含<code>int</code>和<code>bool</code>的值。带有字段的Java类也是一种类似的东西。</p>
<p>One-of类型也很常见，但不幸的是，在许多编程入门课程中，它们并没有得到太多强调。<code>int option</code>是一个简单的示例：此类型的值包含<code>int</code>或不包含。对于在ML中包含<code>int</code>或<code>bool</code>的类型，我们需要数据类型绑定，这是本节课程的主要重点。在像Java这样的类的面向对象语言中，有一种类型是通过子类化实现的，但这是本课程后面要讨论的主题。</p>
<p>Self-reference允许类型描述递归数据结构。这对于Each-of类型和One-of类型的组合都很有用。例如，<code>int list</code>描述的值要么不包含任何内容，要么包含一个<code>int</code>和另一个<code>int list</code>。任何编程语言中的整数列表都可以用or、and和self-reference来描述，因为这就是整数列表的含义。</p>
<p>当然，因为复合类型可以嵌套，所以我们可以对each-of、one-of和self-reference进行任何嵌套。例如，考虑类型<code>(int * bool) list list * (int option) list * bool</code>。</p>
<h2 id="记录：“Each-of”类型的另一种方法"><a href="#记录：“Each-of”类型的另一种方法" class="headerlink" title="记录：“Each-of”类型的另一种方法"></a>记录：“Each-of”类型的另一种方法</h2><p>记录类型是“Each-of”类型，其中每个组件都是一个命名字段。例如，类型<code>&#123;foo: int，bar: int*bool，baz: bool*int&#125;</code>用三个名为<code>foo</code>，<code>bar</code>和<code>baz</code>的字段描述记录。这只是一种新的类型，就像元组类型在我们学习时是新的一样。</p>
<p>记录表达式生成记录值。例如，表达式<code>&#123;bar = (1+2, true andalso true)，foo = 3+4，baz = (false, 9)&#125;</code>将计算为记录值<code>&#123;bar = (1+2, true)，foo = 7，baz = (false, 9)&#125;</code>，它有类型<code>&#123;foo: int，bar: int*bool，baz: bool*int&#125;</code>，因为字段的顺序并不重要（我们使用字段名）。一般来说，记录表达式的语法是<code>&#123;f1 = e1, …, fn = en&#125;</code>，其中，一如既往，每个<code>ei</code>可以是任何表达式。在这里，每个<code>f</code>可以是任何字段名（尽管每个字段名必须不同）。字段名基本上是任何字母或数字序列。</p>
<p>在ML中，我们不需要声明我们想要一个具有特定字段名和字段类型的记录类型——我们只需要写下一个记录表达式，类型检查器就会为它提供正确的类型。记录表达式的类型检查规则并不奇怪：对每个表达式进行类型检查，以获得一些类型<code>ti</code>，然后构建具有所有正确字段和正确类型的记录类型。因为字段名的顺序并不重要，所以打印时REPL总是按字母顺序排列，以保持一致性。</p>
<p>记录表达式的求值规则类似：将每个表达式求值为一个值，并创建相应的记录值。</p>
<p>既然我们知道了如何建立记录值，我们需要一种方法来访问它们的片段。现在，我们将使用<code>#foo e</code>，其中<code>foo</code>是一个字段名。类型检查要求<code>e</code>具有一个名为<code>foo</code>的字段的记录类型，如果该字段具有类型<code>t</code>，那么这就是<code>#foo e</code>的类型。评估将<code>e</code>评估为一个记录值，然后生成<code>foo</code>字段的内容。</p>
<h2 id="根据名称-vs-根据位置，语法糖和元组的真相"><a href="#根据名称-vs-根据位置，语法糖和元组的真相" class="headerlink" title="根据名称 vs 根据位置，语法糖和元组的真相"></a>根据名称 vs 根据位置，语法糖和元组的真相</h2><p>记录和元组非常相似。它们都是允许任意数量组件的“each-of”结构。唯一真正的区别是记录是“按名称”的，元组是“按位置”的。这意味着对于记录，我们通过使用字段名来构建它们并访问它们的片段，因此我们在记录表达式中写入字段的顺序并不重要。但是元组没有字段名，所以我们使用位置（第一，第二，第三，…）以区分组件。</p>
<p>在设计语言结构或选择使用哪种语言结构时，按名称与按位置是一个典型的决定，在某些情况下，两者都很方便。作为一个粗略的指南，对于少量的组件来说，按位置是比较简单的，但是对于较大的复合类型来说，它变得很难记住哪个位置是哪个。</p>
<p>Java方法参数（以及我们到目前为止所描述的ML函数参数）实际上采用了一种混合方法：方法体使用变量名来引用不同的参数，但调用方按位置传递参数。在其他语言中，调用者按名称传递参数。（短语“按名称调用”实际上意味着与函数参数有关的其他内容，这是另一个话题。）</p>
<p>尽管“按名称vs.按位置”，记录和元组仍然非常相似，我们可以完全根据记录来定义元组。以下是方法：</p>
<ul>
<li>当你写<code>(e1,…,en)</code>时，这是另一种写<code>&#123;1=e1,...,n=en&#125;</code>的方法，也就是说，元组表达式是字段名为$1,2,\ldots,n$的记录表达式</li>
<li><code>t1 * ... * tn</code>只是另一种写<code>&#123;1:t1,…,n:tn&#125;</code>的方式。</li>
<li>请注意，<code>#1 e</code>、<code>#2 e</code>等，现在已经表示正确的事情：获取名为1、2等的字段的内容。</li>
</ul>
<p>事实上，ML就是这样定义元组的：元组就是一个记录。也就是说，元组的所有语法只是记录和使用记录的一种简便方式。REPL总是在可能的情况下使用元组语法，因此如果计算<code>&#123;2=1+2, 1=3+4&#125;</code>，它会将结果打印为<code>(7,3)</code>。使用元组语法是更好的风格，但我们不需要赋予元组自己的语义：我们可以使用上面的“另一种编写方式”规则，然后对记录重用语义。</p>
<p>这是我们将看到的许多语法糖例子中的第一个。我们说，“元组只是字段名为$1,2,\ldots,n$的记录的语法糖。”它是关于语法的，因为我们可以用等价的记录语法来描述元组的一切。它是糖，因为它使语言更甜。语法糖这个词被广泛使用。语法糖是一种很好的方法，可以使编程语言中的关键思想保持小（使其更易于实现），同时为程序员提供方便的编写方法。事实上，在家庭作业1中，我们使用元组时并不知道记录的存在，即使元组是记录。</p>
<h2 id="数据类型绑定：我们自己的“One-of”类型"><a href="#数据类型绑定：我们自己的“One-of”类型" class="headerlink" title="数据类型绑定：我们自己的“One-of”类型"></a>数据类型绑定：我们自己的“One-of”类型</h2><p>我们现在介绍数据类型绑定，这是继变量绑定和函数绑定之后的第三种绑定。我们从一个愚蠢但简单的例子开始，因为它将帮助我们了解数据类型绑定的许多不同方面。我们可以写：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype mytype &#x3D; TwoInts of int * int
                | Str of string
			   | Pizza<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>粗略地说，这定义了一种新类型，其中值为<code>int * int</code>，字符串，或者什么都没有。任何值都会被信息“标记”，让我们知道它是哪种变体：这些“标记”，我们称之为构造函数，是<code>TwoInts</code>、<code>Str</code>和<code>Pizza</code>。可以使用两个构造函数标记相同类型的基本数据；事实上，这很常见，尽管我们的示例对每个变体使用不同的类型。</p>
<p>更准确地说，上面的示例向环境中添加了四件事：</p>
<ul>
<li>一个新类型<code>mytype</code>，我们现在可以像任何其他类型一样使用它</li>
<li>三个构造函数<code>TwoInts</code>、<code>Str</code>和<code>Pizza</code></li>
</ul>
<p>一个构造函数是两个不同的东西。首先，它要么是一个用于创建新类型值的函数，要么实际上是一个新类型值。在我们的示例中，<code>TwoInts</code>是<code>int * int -&gt; mytype</code>类型的函数，<code>Str</code>是<code>string -&gt; mytype</code>类型的函数，<code>Pizza</code>是<code>mytype</code>类型的值。其次，我们在<code>case</code>表达式中使用构造函数，如下所述。</p>
<p>所以我们知道如何构建<code>mytype</code>类型的值：使用正确类型的表达式调用构造函数（它们是函数）（或者只使用<code>Pizza</code>值）。这些函数调用的结果是“知道它们是哪个变量”（它们存储一个“标记”）的值，并将底层数据传递给构造函数。REPL用例如<code>TwoInts(3,4)</code>或<code>Str “hi”</code>表示这些值。</p>
<p>剩下的就是找回piece的方法。</p>
<h2 id="ML如何不提供对数据类型值的访问"><a href="#ML如何不提供对数据类型值的访问" class="headerlink" title="ML如何不提供对数据类型值的访问"></a>ML如何不提供对数据类型值的访问</h2><p>给定<code>mytype</code>类型的值，我们如何访问其中存储的数据？首先，我们需要找出它是哪种变体，因为<code>mytype</code>类型的值可能是由<code>TwoInts</code>、<code>Str</code>或<code>Pizza</code>生成的，这会影响可用的数据。一旦我们知道我们有什么变体，我们就可以访问该变体携带的片段（如果有的话）。</p>
<p>回想一下我们是如何为列表和选项这样做的，它们也是一种类型：我们有用于测试我们拥有的变量（<code>null</code>或<code>isSome</code>）的函数，以及用于获取片段（<code>hd</code>、<code>tl</code>或<code>valOf</code>）的函数，如果使用错误的参数，这些函数会引发异常。</p>
<p>ML可以对数据类型绑定采用相同的方法。例如，它可以采用上面的数据类型定义，并向环境添加<code>mytype -&gt; bool</code>类型的函数<code>isTwoInts</code>、<code>isStr</code>和<code>isPizza</code>。它还可以添加一些函数，比如<code>mytype -&gt; int*int</code>类型的<code>getTwoInts</code>和<code>mytype-&gt;string</code>类型的<code>getStr</code>，这可能会引发异常。</p>
<p>但ML不采用这种方法。相反，它做得更好。你可以用更好的东西自己编写这些函数，尽管这样做通常不太合适。事实上，在学习了更好的东西之后，我们将不再像以前那样使用列表和选项的函数——我们只是从这些函数开始，以便我们可以一次学习一件事情。</p>
<h2 id="ML如何提供对数据类型值的访问：Case表达式"><a href="#ML如何提供对数据类型值的访问：Case表达式" class="headerlink" title="ML如何提供对数据类型值的访问：Case表达式"></a>ML如何提供对数据类型值的访问：Case表达式</h2><p>更好的是case表达式。下面是我们的数据类型绑定示例的一个基本例子：</p>
<pre class="line-numbers language-none"><code class="language-none">fun f x &#x3D; (* f has type mytype -&gt; int *) 
		case x of
        Pizza &#x3D;&gt; 3
      | TwoInts(i1,i2) &#x3D;&gt; i1 + i2
      | Str s &#x3D;&gt; String.size s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在某种意义上，case表达式就像一个更强大的if-then-else表达式。就像条件表达式一样，它评估两个子表达式：首先是关键字case和of之间的表达式，其次是第一个分支中匹配的表达式。但是，我们可以为我们的数据类型的每个变体有一个分支，而不是有两个分支（一个为true，一个为false）（我们将在下面进一步概括）。与条件表达式一样，每个分支的表达式必须具有相同的类型（在上面的例子中是<code>int</code>），因为类型检查器无法知道将使用哪个分支。</p>
<p>每个分支都有<code>p =&gt; e</code>的形式，其中<code>p</code>是一个模式，<code>e</code>是一个表达式，我们用<code>|</code>字符来分隔这些分支。模式看起来像表达式，但不要把它们看成是表达式。相反，它们被用来与评估case的表达式（<code>case</code>后面的部分）的结果进行匹配。这就是为什么评估一个case表达式被称为模式匹配。</p>
<p>在本讲座中，我们保持模式匹配的简单性。每个模式都使用一个不同的构造函数，模式匹配会根据case后面的表达式挑选出”正确的”分支。评估该分支的结果就是总体答案；不评估其他分支。例如，如果 <code>TwoInts(7,9)</code>被传递给<code>f</code>，那么第二个分支将被选择。</p>
<p>这就解决了使用one-of类型的”检查变体”部分，但模式匹配也解决了”取出底层数据 “部分。由于TwoInts有两个”携带”的值，它的模式可以（而且现在必须）使用两个变量（<code>(i1,i2)</code>）。作为匹配的一部分，值的相应部分（继续我们的例子，7和9）被绑定到<code>i1</code>和<code>i2</code>的环境中，用来评估相应的右边（<code>i1+i2</code>）。在这个意义上，模式匹配就像一个let-表达式。它将变量绑定在一个局部范围内。类型检查器知道这些变量有什么类型，因为它们是在创建模式中使用的构造函数的数据类型绑定中指定的。</p>
<p>为什么在测试变体和提取片段时，case表达式比函数更好？</p>
<ul>
<li>我们永远不会”搞砸”并试图从错误的变体中提取东西。也就是说，我们不会像使用<code>hd []</code>那样得到异常。</li>
<li>如果一个case表达式忘记了一个变体，那么类型检查器将给出一个警告信息。这表明评估case表达式找不到匹配的分支，在这种情况下它会引发一个异常。如果你没有这样的警告，那么你知道这种情况不会发生。</li>
<li>如果一个case表达式两次使用一个变体，那么类型检查器将给出一个错误信息，因为其中一个分支不可能被使用。</li>
<li>如果你还想要<code>null</code>和<code>hd</code>这样的函数，你可以很容易地自己写出来（但不要为你的家庭作业这样做）。</li>
<li>模式匹配比我们到目前为止所指出的要普遍和强大得多。我们在下面给出关于模式匹配的”全部真相”。</li>
</ul>
<h2 id="“One-of”类型的有用例子"><a href="#“One-of”类型的有用例子" class="headerlink" title="“One-of”类型的有用例子"></a>“One-of”类型的有用例子</h2><p>现在让我们考虑几个”one-of”类型有用的例子，因为到目前为止我们只考虑了一个愚蠢的例子。</p>
<p>首先，它们适合于枚举一组固定的选项，比起使用小整数的风格好得多，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype suit &#x3D; Club | Diamond | Heart | Spade<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>许多语言都支持这种枚举，包括Java和C，但ML更进一步，让变体携带数据，所以我们可以做这样的事情： </p>
<pre class="line-numbers language-none"><code class="language-none">datatype rank &#x3D; Jack | Queen | King | Ace | Num of int <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后我们可以用each-of类型组合这两块： suit * rank。</p>
<p>One-of类型在不同情况下有不同数据时也很有用。例如，假设你想通过id-numbers来识别学生，但如果有的学生没有id-numbers（也许他们是新来的），那么你就用他们的全名来代替（包括名字，可选的中间名和姓氏）。这个数据类型绑定直接抓住了这个想法：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype id &#x3D; StudentNum of int
            | Name of string * (string option) * string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果程序员对one-of类型缺乏理解，坚持使用each-of类型，就会像把锯子当作锤子一样（尽管可以工作，但实际上做错了），考虑像这样的不好代码：</p>
<pre class="line-numbers language-none"><code class="language-none">(* If student_num is -1, then use the other fields, otherwise ignore other fields *)
 &#123;student_num : int, first : string, middle : string option, last : string&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这种方法要求所有的代码都要遵循注释中的规则，没有类型检查器的帮助。它还浪费了空间，在每条记录中都有不应该使用的字段。</p>
<p>另一方面，如果我们想为每个学生存储他们的ID号码（如果他们有的话）和他们的全名，那么each-of类型都是正确的方法：</p>
<pre class="line-numbers language-none"><code class="language-none">&#123; student_num : int option,
	first	  : string,
	middle	  : string option,
	last	  : string &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们的最后一个例子是一个包含常数、负数、加法和乘法的算术表达式的数据定义：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype exp &#x3D; Constant of int
             | Negate of exp
             | Add of exp * exp
             | Multiply of exp * exp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于自引用，这个数据定义真正描述的是树，其中叶子节点是整数，内部节点是子节点取相反数，两个子节点的加法或有两个子节点的乘法。我们可以写一个函数，接收一个exp并对其进行评估： </p>
<pre class="line-numbers language-none"><code class="language-none">fun eval e &#x3D;
    case e of
        Constant i &#x3D;&gt; i
      | Negate e2  &#x3D;&gt; ~ (eval e2)
      | Add(e1,e2) &#x3D;&gt; (eval e1) + (eval e2)
      | Multiply(e1,e2) &#x3D;&gt; (eval e1) * (eval e2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以下面的结果是15：</p>
<pre class="line-numbers language-none"><code class="language-none">eval (Add (Constant 19, Negate (Constant 4)))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意，构造函数只是我们用其他表达式（通常是由构造函数构建的其他值）调用的函数。</p>
<p>我们可以在<code>exp</code>类型的值上编写许多函数，其中大部分都会以类似的方式使用模式匹配和递归。下面是你可以编写的处理<code>exp</code>参数的其他函数。</p>
<ul>
<li>表达式中最大的常数</li>
<li>表达式中所有常数的列表（使用列表apeend）</li>
<li>表示表达式中是否至少有一个乘法操作的<code>bool</code>变量</li>
<li>表达式中加法表达式的数量 </li>
</ul>
<p>这里是最后一个函数：</p>
<pre class="line-numbers language-none"><code class="language-none">fun number_of_adds e &#x3D;
    case e of
        Constant i		&#x3D;&gt; 0
      | Negate e2	    &#x3D;&gt; number_of_adds e2
      | Add(e1,e2)	    &#x3D;&gt; 1 + number_of_adds e1 + number_of_adds e2
      | Multiply(e1,e2) &#x3D;&gt; number_of_adds e1 + number_of_adds e2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="数据类型绑定和Case表达式到目前为止，准确地描述"><a href="#数据类型绑定和Case表达式到目前为止，准确地描述" class="headerlink" title="数据类型绑定和Case表达式到目前为止，准确地描述"></a>数据类型绑定和Case表达式到目前为止，准确地描述</h2><p>我们可以把到目前为止对数据类型和模式匹配的了解总结如下：绑定</p>
<pre class="line-numbers language-none"><code class="language-none">datatype t &#x3D; C1 of t1 | C2 of t2 | ... | Cn of tn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>引入了一个新的类型<code>t</code>，每个构造函数<code>Ci</code>都是一个<code>ti-&gt;t</code>类型的函数。对于”不携带任何东西”的变体，可以省略”<code>of ti</code>“，这样的构造函数只有类型<code>t</code>。为了”获得<code>t</code>的piece”，我们使用case表达式：</p>
<pre class="line-numbers language-none"><code class="language-none">case e of p1 &#x3D;&gt; e1 | p2 &#x3D;&gt; e2 | ... | pn &#x3D;&gt; en<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一个case表达式将<code>e</code>评估为一个值<code>v</code>，找到第一个与<code>v</code>相匹配的模式<code>pi</code>，并评估<code>ei</code>以产生整个case表达式的结果。到目前为止，模式看起来像<code>Ci(x1,...,xn)</code>，其中<code>Ci</code>是一个类型为<code>t1 * ... * tn -&gt; t</code>的构造函数（或者如果<code>Ci</code>没有携带任何东西，则只有<code>Ci</code>）。这样的模式与形式为<code>Ci(v1,...,vn)</code>的值相匹配，并将每个<code>xi</code>与<code>vi</code>绑定，以评估相应的<code>ei</code>。</p>
<h2 id="类型同义词"><a href="#类型同义词" class="headerlink" title="类型同义词"></a>类型同义词</h2><p>在继续讨论数据类型之前，让我们把它们与另一种有用的绑定进行对比，它也引入了一个新的类型名称。一个类型同义词只是为一个现有的类型创建了另一个名字，这个名字完全可以和现有的类型互换。</p>
<p>例如，如果我们写</p>
<pre class="line-numbers language-none"><code class="language-none">type foo &#x3D; int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么我们就可以在写<code>int</code>的地方写<code>foo</code>，反之亦然。因此，给定一个<code>foo-&gt;foo</code>类型的函数，我们可以对该函数调用参数3，并将结果加到4中。 REPL有时会打印<code>foo</code>，有时会打印<code>int</code>，这取决于情况；细节不重要，由语言实现决定。对于像<code>int</code>这样的类型，这样的同义词不是很有用（尽管以后当我们研究ML的模块系统时，我们将建立在这个特性上）。</p>
<p>但是对于更复杂的类型，创建类型同义词可能会很方便。下面是我们上面创建的类型的一些例子：</p>
<pre class="line-numbers language-none"><code class="language-none">type card &#x3D; suit * rank
type name_record &#x3D; &#123; student_num : int option,
                     first		: string,
                     middle		: string option,
                     last		: string &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只要记住这些同义词是完全可以互换的。例如，如果一个家庭作业问题需要一个类型<code>为card -&gt; int</code>的函数，而REPL报告你的解决方案的类型为<code>suit * rank -&gt; int</code>，这没有问题，因为这些类型是”相同的”。</p>
<p>相反，数据类型绑定引入了一个与任何现有类型都不相同的类型。它创建了构造函数，产生这个新类型的值。因此，唯一与<code>suit</code>相同的类型是<code>suit</code>，除非我们以后为它引入一个同义词。</p>
<h2 id="列表和选项是数据类型"><a href="#列表和选项是数据类型" class="headerlink" title="列表和选项是数据类型"></a>列表和选项是数据类型</h2><p>因为数据类型的表示可以是递归的，我们可以用它们来为列表创建我们自己的类型。例如，这种绑定方式对整数链表很有效：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype my_int_list &#x3D; Empty
				   | Cons of int * my_int_list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们可以使用构造函数<code>Empty</code>和<code>Cons</code>来创建<code>my_int_list</code>的值，我们可以使用<code>case</code>表达式来使用这些值（在这个例子中，我们使用了变量<code>xs&#39;</code>。许多语言不允许在变量名中使用’这个字符，但ML允许，而且在数学中通常使用它，并将这样的变量读作 “exes prime”。）：</p>
<pre class="line-numbers language-none"><code class="language-none">val one_two_three &#x3D; Cons(1,Cons(2,Cons(3,Empty)))
fun append_mylist (xs,ys) &#x3D;
    case xs of
    	Empty &#x3D;&gt; ys
      |	Cons(x,xs&#39;) &#x3D;&gt; Cons(x, append_mylist(xs&#39;,ys))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>原来，“内置的”列表和选项（即。 预设了一些特殊的语法支持）只是一些数据类型。作为风格问题，使用内置的广为人知的功能比自己发明的要好。</p>
<p>更重要的是，使用模式匹配来访问列表和选项的值是更好的风格，而不是我们之前看到的<code>null, hd, tl, isSome, valOf</code>函数。(我们使用它们是因为我们还没有学模式匹配，我们不想耽误练习函数式编程的技能）。</p>
<p>对于选项，你只需要知道<code>SOME</code>和<code>NONE</code>是构造函数，我们用它们来创建值（就像以前一样），并在模式中访问这些值。下面是一个关于后者的简短例子： </p>
<pre class="line-numbers language-none"><code class="language-none">fun inc_or_zero intoption &#x3D;
    case intoption of
    	NONE &#x3D;&gt; 0
      | SOME i &#x3D;&gt; i+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列表的情况类似，但有一些方便的语法特点。<code>[]</code>实际上是一个不携带任何内容的构造函数，而<code>::</code>实际上是一个携带两个东西的构造函数，但<code>::</code>是不寻常的，因为它是一个infix操作符（它被放在它的两个操作数之间），在创建内容和模式中都是如此：</p>
<pre class="line-numbers language-none"><code class="language-none">fun sum_list xs &#x3D;
    case xs of
    	[] &#x3D;&gt; 0
      |	x::xs&#39; &#x3D;&gt; x + sum_list xs&#39;
    
fun append (xs,ys) &#x3D;
    case xs of
    	[] &#x3D;&gt; ys
      | x::xs&#39; &#x3D;&gt; x :: append(xs&#39;,ys)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意这里<code>x</code>和<code>xs&#39;</code>只不过是通过模式匹配引入的局部变量。我们可以使用任何我们想要的变量的名字。我们甚至可以使用<code>hd</code>和<code>tl</code>，这样做只是对外部环境中预设的函数进行shadow。</p>
<p>在访问列表和选项时，你通常应该选择模式匹配，而不是像<code>null</code>和<code>hd</code>这样的函数，其原因与一般的数据类型绑定相同：你不能忘记某些情形，你不能应用错误的函数，等等。那么，如果方法不够好，为什么ML环境会预设这些函数呢？部分原因是它们在作为参数传递给其他函数时很有用，这是本课程下一节的一个主要话题。</p>
<h2 id="多态数据类型"><a href="#多态数据类型" class="headerlink" title="多态数据类型"></a>多态数据类型</h2><p>除了<code>[]</code>和<code>::</code>的奇怪语法外，内置列表和选项与我们的数据类型绑定示例的唯一区别是，内置列表和选项是多态的——它们可以用来携带任何类型的值，正如我们所看到的<code>int list, int list list, (bool * int) list</code>等。你也可以为你自己的数据类型绑定做到这一点，事实上，这对于构建”通用”数据结构非常有用。虽然我们在这里不会重点讨论这个功能的使用（也就是说，你没有责任知道如何去做），但这并没有什么非常复杂的地方。例如，这正是选项在环境中的预设方式：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype &#39;a option &#x3D; NONE | SOME of &#39;a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样的绑定并没有引入类型选项。相反，它使得如果<code>t</code>是一个类型，那么<code>t option</code>也是一个类型。你也可以设计多态数据类型，它可以接受多种类型。例如，这里有一棵二叉树，内部节点持有<code>&#39;a</code>类型的值，叶子持有<code>&#39;b</code>类型的值：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype (&#39;a,&#39;b) tree &#x3D; Node of &#39;a * (&#39;a,&#39;b) tree * (&#39;a,&#39;b) tree
					| Leaf of &#39;b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后我们就有了<code>(int, int) tree</code>（其中每个节点和叶子都持有一个int）和<code>(string, bool) tree</code>（其中每个节点持有一个字符串，每个叶子节点持有一个bool）等类型。对于普通数据类型和多态数据类型，使用构造函数和模式匹配的方式是一样的。</p>
<h2 id="Each-Of类型的模式匹配：关于值绑定的真相"><a href="#Each-Of类型的模式匹配：关于值绑定的真相" class="headerlink" title="Each-Of类型的模式匹配：关于值绑定的真相"></a>Each-Of类型的模式匹配：关于值绑定的真相</h2><p>到目前为止，我们已经将模式匹配用于one-of类型，但我们也可以将其用于each-of类型。给定一个记录值<code>&#123;f1=v1,...,fn=vn&#125;</code>，模式<code>&#123;f1=x1,...,fn=xn&#125;</code>匹配并将<code>xi</code>绑定到<code>vi</code>。正如你所期望的，模式中字段的顺序并不重要。如前所述，元组是记录的语法糖：模式<code>(x1,...,xn)</code>与<code>&#123;1=x1,...,n=xn&#125;</code>相同，并且与元组值<code>(v1,...,vn)</code>匹配，后者与<code>&#123;1=v1,...,n=vn&#125;</code>相同。所以我们可以写如下函数来求一个<code>int * int * int</code>的三个部分的和： </p>
<pre class="line-numbers language-none"><code class="language-none">fun sum_triple (triple : int * int * int) &#x3D;
    case triple of
    	(x,y,z) &#x3D;&gt; z + y + x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>而用记录（和ML的字符串连接运算符）的类似例子可以是这样：</p>
<pre class="line-numbers language-none"><code class="language-none">fun full_name (r : &#123;first:string,middle:string,last:string&#125;) &#x3D;
    case r of
    	&#123;first&#x3D;x,middle&#x3D;y,last&#x3D;z&#125; &#x3D;&gt; x ^ &quot; &quot; ^ y ^ &quot; &quot; ^z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>然而，只有一个分支的case-expression的风格很差，因为这种表达方式的目的是区分cases（多个case）。那么，当我们知道一个单一的模式将确定匹配时，我们应该如何对每个类型使用模式匹配，以为了方便提取值？事实证明，你也可以在值绑定中使用模式！所以如下方法是更好的风格： </p>
<pre class="line-numbers language-none"><code class="language-none">fun full_name (r : &#123;first:string,middle:string,last:string&#125;) &#x3D;
    let val &#123;first&#x3D;x,middle&#x3D;y,last&#x3D;z&#125; &#x3D; r
    in
    	x ^ &quot; &quot; ^ y ^ &quot; &quot; ^z
    end

fun sum_triple (triple : int*int*int) &#x3D;
    let val (x,y,z) &#x3D; triple
    in
    	x + y + z
    end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上我们可以做得更好。就像在val绑定中可以使用模式将变量（如x、y和z）绑定到表达式（如triple）的各个部分一样，我们可以在确定函数绑定时使用模式，模式将通过与函数调用时传递的值进行匹配来引入绑定。因此，对于我们的示例函数，这里是第三种也是最好的方法：</p>
<pre class="line-numbers language-none"><code class="language-none">fun full_name &#123;first&#x3D;x,middle&#x3D;y,last&#x3D;z&#125; &#x3D;
	x ^ &quot; &quot; ^ y ^ &quot; &quot; ^z

fun sum_triple (x,y,z) &#x3D;
	x + y + z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个版本的<code>sum_triple</code>应该让你感兴趣。它接受triple作为参数，并使用模式匹配将三个变量绑定到三个片段上，以便在函数主体中使用。但它看起来完全像一个接受三个int类型参数的函数。事实上，<code>int*int*int-&gt;int</code>类型是用于三参数函数还是用于的单参数triple函数？</p>
<p>事实证明，我们基本上一直在撒谎。在ML中不存在多参数函数：<strong>ML中的每个函数都只接收一个参数</strong>! 每当我们写一个多参数函数时，我们实际上是在写一个单参数函数，它以一个元组为参数，使用模式匹配来提取片段。这是一个很常见的习语，很容易让人忘记，而且在和朋友讨论ML代码时，完全可以说成是”多参数函数”。但就实际的语言定义而言，它确实是一个单参数函数：用单case表达式扩展出<code>sum_triple</code>的第一个版本的语法糖。</p>
<p>这种灵活性有时是很有用的。在像C和Java这样的语言中，你不能让一个函数/方法计算的结果立即传递给另一个多参数函数/方法。但是对于作为元组的单参数函数，这就很好用。这里有一个愚蠢的例子，我们通过”向左旋转三元组两次”来得到“向右旋转三元组”：</p>
<pre class="line-numbers language-none"><code class="language-none">fun rotate_left (x,y,z) &#x3D; (y,z,x)
fun rotate_right triple &#x3D; rotate_left(rotate_left triple)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>更一般地说，你可以计算元组，然后将它们传递给函数，即使该函数的作者是以多参数的方式思考的。</p>
<p>那么零参数的函数呢？它们也不存在。绑定函数<code>f () = e</code>是使用单位模式<code>()</code>来匹配传递单位值<code>()</code>的调用，这是<code>unit</code>类型唯一的值。unit类型只是一个只有一个构造函数的数据类型，它不需要参数，并且使用不寻常的语法<code>()</code>。基本地，数据类型<code>unit = ()</code>是预先设定好的。</p>
<h2 id="题外话：类型推理"><a href="#题外话：类型推理" class="headerlink" title="题外话：类型推理"></a>题外话：类型推理</h2><p>通过使用模式来访问元组和记录值，而不是<code>#foo</code>，你会发现不再需要在函数参数上写类型。事实上，在ML中，传统的做法是不写类型，你可以随时使用REPL来找出函数的类型。我们以前需要它们的原因是<code>#foo</code>没有提供足够的信息对函数进行类型检查，因为类型检查器不知道记录应该有哪些其他的域，但是上面介绍的记录/元组模式提供了这些信息。在ML中，每个变量和函数都有一个类型（否则你的程序就无法进行类型检查）——类型推理只是意味着你不需要写下类型。</p>
<p>所以我们上面使用模式匹配而不是<code>#middle</code>或<code>#2</code>的例子都不需要参数类型。写这些不那么杂乱的版本往往是更好的风格，其中又以最后一个版本为最佳：</p>
<pre class="line-numbers language-none"><code class="language-none">fun sum_triple triple &#x3D;
    case triple of
    	(x,y,z) &#x3D;&gt; z + y + x
    	
fun sum_triple triple &#x3D;
    let val (x,y,z) &#x3D; triple
    in
    	x + y + z
    end

fun sum_triple (x,y,z) &#x3D;
	x + y + z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个版本的参数需要一个显式类型：</p>
<pre class="line-numbers language-none"><code class="language-none">fun sum_triple (triple : int * int * int) &#x3D;
	#1 triple + #2 triple + #3 triple<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>原因是类型检查器不能从<code>fun sum_triple triple = #1 triple + #2 triple + #3 triple</code>中推断出参数必须有<code>int*int*int</code>类型，因为它也可能有<code>int*int*int*int*string</code>或<code>int*int*int*bool*string</code>或无限数量的其他类型。如果你不使用<code>#</code>，由于类型推理的便利，ML几乎不需要明确的类型注释。</p>
<p>事实上，类型推理有时会让函数比你想象的更通用。考虑一下这段代码，它确实使用了元组/记录的一部分：</p>
<pre class="line-numbers language-none"><code class="language-none">fun partial_sum (x,y,z) &#x3D; x + z
fun partial_name &#123;first&#x3D;x, middle&#x3D;y, last&#x3D;z&#125; &#x3D; x ^ &quot; &quot; ^ z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在这两种情况下，推断的函数类型揭示了y的类型可以是任何类型，所以我们可以调用<code>partial_sum (3,4,5)</code>或 <code>partial_sum (3,false,5)</code> 。</p>
<p>我们将在以后的章节中讨论这些多态函数以及类型推理如何工作，因为它们本身就是主要的课程主题。现在，只要停止使用<code>#</code>，停止写参数类型，如果你偶尔看到像<code>&#39;a</code>或<code>&#39;b</code>这样的类型，也不要感到困惑，因为类型推理在接下来会有更多讨论。</p>
<h2 id="题外话：多态类型和等价类型"><a href="#题外话：多态类型和等价类型" class="headerlink" title="题外话：多态类型和等价类型"></a>题外话：多态类型和等价类型</h2><p>我们现在鼓励你在程序中不做明确的类型注释，但正如上面所看到的，这可能会导致令人惊讶的一般类型。假设你被要求写一个类型为<code>int*int*int-&gt;int</code>的函数，其行为类似于上面的<code>partial_sum</code>，但是REPL正确地指出<code>partial_sum</code>的类型为<code>int*&#39;a*int-&gt;int</code>。这没关系，因为多态性表明<code>partial_sum</code>有一个更通用的类型。如果你能把一个包含<code>&#39;a, &#39;b, &#39;c</code>等的类型，并把这些类型变量的每一个都替换成你想要的类型，那么你就有一个比你想要的类型更通用的类型。</p>
<p>再举个例子，我们写的<code>append</code>的类型是<code>&#39;a list * &#39;a list -&gt; &#39;a list</code>，所以通过持续地用<code>string</code>替换<code>&#39;a</code>，我们可以使用<code>append</code>，好像它的类型是<code>string list * string list -&gt; string list</code>。我们可以对任何类型做这个操作，而不仅仅是字符串。我们实际上没有做任何事情：这只是一个练习，检查一个类型是否比我们需要的类型更通用。注意，像<code>&#39;a</code>这样的类型变量必须被一致替换，这意味着<code>append</code>的类型不比<code>string list * int list -&gt; string list</code>更通用。</p>
<p>你也可能会看到有两个前导撇号的类型变量，比如<code>&#39;&#39;a</code>。这些被称为平等类型，它们是ML的一个相当奇怪的特征，与我们目前的研究不相关。基本上，ML中的=运算符（用于比较事物）对许多类型都有效，不仅仅是<code>int</code>，但它的两个操作数必须具有相同的类型。例如，它对字符串和元组类型都有效，元组中的所有类型都支持等号（例如，<code>int * (string * bool)</code>）。（它对函数不起作用，因为无法判断两个函数是否总是做同样的事情。它也不适用于real类型，因为由于四舍五入的原因，比较它们在算法上几乎总是错误的。）像<code>&#39;&#39;a</code>这样的类型只能用一个”平等类型 “来代替它，但它并不是对每个类型都有效。</p>
<pre class="line-numbers language-none"><code class="language-none">fun same_thing(x,y) &#x3D; if x&#x3D;y then &quot;yes&quot; else &quot;no&quot; (* has type &#39;&#39;a * &#39;&#39;a -&gt; string *)
fun is_three x &#x3D; if x&#x3D;3 then &quot;yes&quot; else &quot;no&quot; (* has type int -&gt; string *)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同样，我们将在后面更多地讨论多态类型和类型推理，但这个题外话对避免作业2的混淆有帮助：如果你写一个函数，REPL给它一个比你需要的更一般的类型，这是好的。也要记住，如上所述，如果REPL使用的类型同义词与你期望的不同，也是可以的。</p>
<h2 id="嵌套模式"><a href="#嵌套模式" class="headerlink" title="嵌套模式"></a>嵌套模式</h2><p>事实证明，模式的表示是递归的：在我们的模式中，凡是有变量的地方，我们都可以放上另一个模式。粗略地说，模式匹配的语义是，被匹配的值必须具有与模式相同的”形状”，并且变量被绑定到”正确的部分”。(这是粗略的解释，这就是为什么下面会描述一个精确的说法)。例如，模式<code>a::(b::(c::d))</code>将匹配任何至少有3个元素的列表，它将把<code>a</code>绑定到第一个元素，<code>b</code>绑定到第二个元素，<code>c</code>绑定到第三个元素，<code>d</code>绑定到包含所有其他元素的列表（如果有）。另一方面，模式<code>a::(b::(c:[]))</code>将只匹配正好有三个元素的列表。另一个嵌套模式是<code>(a,b,c)::d</code>，它匹配任何非空的三元素列表，将<code>a</code>绑定到头部的第一个组件，<code>b</code>绑定到头部的第二个组件，<code>c</code>绑定到头部的第三个组件，<code>d</code>绑定到列表的尾部。</p>
<p>一般来说，模式匹配是指接受一个值和一个模式，</p>
<ul>
<li>(1)决定模式是否与该值匹配，</li>
<li>(2)如果匹配，则将变量绑定到该值的正确部分。</li>
</ul>
<p>以下是模式匹配的优雅递归表示的一些关键部分：</p>
<ul>
<li>一个变量模式(<code>x</code>)匹配任何值<code>v</code>，并引入一个绑定（从<code>x</code>到<code>v</code>）。</li>
<li>模式<code>C</code>匹配值<code>C</code>，如果<code>C</code>是一个不携带数据的构造函数。</li>
<li>模式<code>C p</code>，其中<code>C</code>是一个构造函数，<code>p</code>是一个模式，如果<code>p</code>匹配<code>v</code>（即嵌套模式匹配携带的值），则匹配形式为<code>C v</code>的值（注意构造函数是一样的）。它引入了<code>p</code>匹配<code>v</code>所引入的绑定关系。</li>
<li>如果<code>p1</code>匹配<code>v1</code>，<code>p2</code>匹配<code>v2</code>，…，<code>pn</code>匹配<code>vn</code>，那么模式<code>(p1,p2,...,pn)</code>匹配<code>(v1,v2,...,vn)</code>。它引入了所有递归匹配所引入的绑定关系。</li>
<li>(对于形式为<code>&#123;f1=p1,...,fn=pn&#125;</code>的记录模式也有类似的情况…) </li>
</ul>
<p>这个递归表示以两种有趣的方式扩展了我们以前的理解。首先，对于携带多个参数的构造函数C，我们不必写像<code>C(x1,...,xn)</code>这样的模式，尽管我们经常这样做。我们也可以写<code>C x</code>；这将把<code>x</code>与<code>C(v1,...,vn)</code>对应的元组绑定。真正的情况是，所有构造函数都接受0或1个参数，但参数本身可以是一个元组。所以<code>C(x1,...,xn)</code>实际上是一个嵌套模式，其中<code>(x1,...,xn)</code>部分只是一个匹配所有具有$n$个部分的元组的模式。其次，更重要的是，当我们想只匹配具有某种”形状”的值时，我们可以使用嵌套模式而不是嵌套case表达式。</p>
<p>还有其他类型的模式。有时我们不需要将变量与值的一部分绑定。例如，考虑一下这个计算列表长度的函数： </p>
<pre class="line-numbers language-none"><code class="language-none">fun len xs &#x3D;
    case xs of
    	[] &#x3D;&gt; 0
      |	 x::xs&#39; &#x3D;&gt; 1 + len xs&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们不使用变量x，在这种情况下，不引入变量是更好的风格。\通配符模式<code>_</code>匹配一切（就像变量模式匹配一切），但不引入绑定。所以我们应该写：</p>
<pre class="line-numbers language-none"><code class="language-none">fun len xs &#x3D;
    case xs of
    	[] &#x3D;&gt; 0
      |	 _::xs&#39; &#x3D;&gt; 1 + len xs&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>就我们的一般定义而言，通配符模式是简单的：</p>
<ul>
<li>通配符模式（<code>_</code>）匹配任何值<code>v</code>，并且不引入任何绑定。</li>
</ul>
<p>最后，你可以在模式中使用常整数。例如，模式37匹配值37，并且不引入任何绑定关系。</p>
<h2 id="嵌套模式的有用例子"><a href="#嵌套模式的有用例子" class="headerlink" title="嵌套模式的有用例子"></a>嵌套模式的有用例子</h2><p>使用嵌套模式而不是嵌套case表达式的一个优雅的例子”压缩”或解压缩”列表（下面将讨论例外情况，但不是这个例子的重要部分）：</p>
<pre class="line-numbers language-none"><code class="language-none">exception BadTriple

fun zip3 list_triple &#x3D;
    case list_triple of 
	    ([],[],[]) &#x3D;&gt; []
      | (hd1::tl1,hd2::tl2,hd3::tl3) &#x3D;&gt; (hd1,hd2,hd3)::zip3(tl1,tl2,tl3)
      | _ &#x3D;&gt; raise ListLengthMismatch

fun unzip3 lst &#x3D;
    case lst of
	    [] &#x3D;&gt; ([],[],[])
      | (a,b,c)::tl &#x3D;&gt; let val (l1,l2,l3) &#x3D; unzip3 tl
		              in
			   			(a::l1,b::l2,c::l3)
		       		  end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子检查一个整数列表是否被排序：</p>
<pre class="line-numbers language-none"><code class="language-none">fun nondecreasing xs &#x3D;
    case xs of
		[] &#x3D;&gt; true
       | x::[] &#x3D;&gt; true
       | head::(neck::rest) &#x3D;&gt; (head &lt;&#x3D; neck andalso nondecreasing (neck::rest))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有时通过对两个值的匹配来比较也是很优雅的。这个例子是在不执行乘法的情况下确定一个乘积的符号，这个例子有点傻，但展示了这个想法：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype sgn &#x3D; P | N | Z

fun multsign (x1,x2) &#x3D; 
  let fun sign x &#x3D; if x&#x3D;0 then Z else if x&gt;0 then P else N 
  in
      case (sign x1,sign x2) of
	  (Z,_) &#x3D;&gt; Z
	| (_,Z) &#x3D;&gt; Z
	| (P,P) &#x3D;&gt; P
	| (N,N) &#x3D;&gt; P
	| _     &#x3D;&gt; N (* many say bad style; I am okay with it *)
  end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这最后一种case的风格值得讨论。当你像这样在底部加入一个”catch-all”案例时，你就放弃了对你没有忘记任何case的检查：毕竟，它与前面的case没有匹配的东西都匹配，所以类型检查器肯定不会认为你忘记了任何case。因此，如果使用这种技术，你需要格外小心，列举剩余的情况（在本例中为<code>(N,P)</code>和<code>(P,N)</code>）可能更容易出错。然后，类型检查器仍将确定没有遗漏的情况，因为它必须对使用<code>(Z,_）</code>和<code>(_,Z)</code>进行推理，以确定没有遗漏<code>sgn*sgn</code>类型的可能性。</p>
<h2 id="可选的：函数绑定中的多个case"><a href="#可选的：函数绑定中的多个case" class="headerlink" title="可选的：函数绑定中的多个case"></a>可选的：函数绑定中的多个case</h2><p>到目前为止，我们已经看到在case表达式中对one-of类型进行模式匹配。我们还看到了在val或函数绑定中对each-of类型进行模式匹配的良好风格，这就是”多参数函数”的真正含义。但是有没有办法在val/function绑定中对one-of类型进行匹配？这似乎是个坏主意，因为我们需要多种可能性。但事实证明，ML有特殊的语法可以在函数名称中做到这一点。这里有两个例子，一个是我们自己的数据类型，一个是列表：</p>
<pre class="line-numbers language-none"><code class="language-none">datatype exp &#x3D; Constant of int 
             | Negate of exp 
             | Add of exp * exp
             | Multiply of exp * exp

fun eval (Constant i) &#x3D; i
  | eval (Negate e2) &#x3D; ~ (eval e2)
  | eval (Add(e1,e2)) &#x3D; (eval e1) + (eval e2)
  | eval (Multiply(e1,e2)) &#x3D; (eval e1) * (eval e2)

fun append ([],ys) &#x3D; ys
  | append (x::xs&#39;,ys) &#x3D; x :: append(xs&#39;,ys)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为一个品味问题，你的导师一直不太喜欢这种风格，你必须在正确的地方使用括号。但这在ML程序员中很常见，所以也欢迎你这样做。从语义上讲，它只是一个单一函数体case表达式的语法糖：</p>
<pre class="line-numbers language-none"><code class="language-none">fun eval e &#x3D;
    case e of
        Constant i &#x3D;&gt; i
      | Negate e2  &#x3D;&gt; ~ (old_eval e2)
      | Add(e1,e2) &#x3D;&gt; (old_eval e1) + (old_eval e2)
      | Multiply(e1,e2) &#x3D;&gt; (old_eval e1) * (old_eval e2)

fun append e &#x3D;
    case e of
    	([],ys) &#x3D;&gt; ys
     | 	(x::xs&#39;,ys) &#x3D;&gt; x :: append(xs&#39;,ys)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p> 一般来说，语法</p>
<pre class="line-numbers language-none"><code class="language-none">fun f p1 &#x3D; e1
| 	f p2 &#x3D; e2
...
| 	f pn &#x3D; en<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>只是如下形式的语法糖（从技术上讲，<code>x</code>必须是一些尚未在外部环境中定义并由函数中的表达式之一使用的变量。）：</p>
<pre class="line-numbers language-none"><code class="language-none">fun f x &#x3D;
    case x of
    p1 &#x3D;&gt; e1
  | p2 &#x3D;&gt; e2
...
  | pn &#x3D;&gt; en<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意<code>append</code>的例子使用了嵌套模式：每个分支匹配一对列表，通过把模式（例如<code>[]</code>或<code>x::xs&#39;</code>）放在其他模式里面。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>ML有一个内置的异常概念。你可以用<code>raise</code>基元来引发（也被称为抛出）一个异常。例如，标准库中的<code>hd</code>函数在用<code>[]</code>调用时引发了<code>List.Empty</code>异常。</p>
<pre class="line-numbers language-none"><code class="language-none">fun hd xs &#x3D;
    case xs of
    	[] &#x3D;&gt; raise List.Empty
      | x::_ &#x3D;&gt; x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可以用异常绑定来创建你自己的异常种类。异常可以选择性地携带值，这让引发异常的代码提供更多的信息：</p>
<pre class="line-numbers language-none"><code class="language-none">exception MyUndesirableCondition
exception MyOtherException of int * int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>异常的种类很像数据类型绑定的构造器。事实上，它们是函数（如果它们携带值）或值（如果它们不携带值），它们创建的是<code>exn</code>类型的值而不是数据类型的类型。所以<code>Empty, MyUndesirableCondition, MyOtherException(3,9)</code>都是<code>exn</code>类型的值，而<code>MyOtherException</code>的类型是<code>int*int-&gt;exn</code>。</p>
<p>通常我们只是把异常构造函数作为<code>raise</code>的参数，比如<code>raise MyOtherException(3,9)</code>，但我们可以更广泛地使用它们来创建<code>exn</code>类型的值。例如，这里有一个函数的版本，它返回一个整数列表中的最大元素。如果用<code>[]</code>调用的话，它没有像<code>List.Empty</code>那样返回一个选项或引发一个特殊的异常，它需要一个<code>exn</code>类型的参数并抛出它。所以调用者可以传入其选择的异常。(类型检查器可以推断出<code>ex</code>必须有<code>exn</code>类型，因为那是<code>raise</code>对其参数的期望类型。) </p>
<pre class="line-numbers language-none"><code class="language-none">fun maxlist (xs,ex) &#x3D;
    case xs of
    	[] &#x3D;&gt; raise ex
    |  	x::[] &#x3D;&gt; x
    | 	x::xs&#39; &#x3D;&gt; Int.max(x,maxlist(xs&#39;,ex))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，调用<code>maxlist([3,4,0], List.Empty)</code>不会引发一个异常；这个调用将异常值传递给函数，然后函数不会引发这个异常。</p>
<p>与异常有关的另一个特征是处理（也被称为捕获）异常。为此，ML有异常处理，它看起来像<code>e1 handle p =&gt; e2</code>，其中<code>e1</code>和<code>e2</code>是表达式，<code>p</code>是一个匹配异常的模式。其语义是对<code>e1</code>进行评估，并将其结果作为答案。但是如果<code>e1</code>引发了一个与<code>p</code>匹配的异常，那么<code>e2</code>就会被评估，这就是整个表达式的答案。如果<code>e1</code>引发了一个与<code>p</code>不匹配的异常，那么整个句柄表达式也会引发这个异常。同样地，如果<code>e2</code>引发了一个异常，那么整个表达式也会引发一个异常。</p>
<p>和case-expressions一样，handle-expression也可以有多个分支，每个分支都有一个模式和表达式，在语法上用|分隔。</p>
<h2 id="尾递归和累加器"><a href="#尾递归和累加器" class="headerlink" title="尾递归和累加器"></a>尾递归和累加器</h2><p>本专题涉及新的编程习惯，但没有新的语言结构。这里定义了尾递归，描述了它与在ML等函数式语言中编写高效递归函数的关系，并介绍了如何使用累加器作为一种技术来使一些函数成为尾递归。</p>
<p>为了理解尾递归和累加器，请考虑这些用于对一个列表中的元素进行求和的函数。</p>
<pre class="line-numbers language-none"><code class="language-none">fun sum1 xs &#x3D;
    case xs of
        [] &#x3D;&gt; 0
      | i::xs’ &#x3D;&gt; i + sum1 xs’
      
fun sum2 xs &#x3D;
    let fun f (xs,acc) &#x3D;
            case xs of
                [] &#x3D;&gt; acc
              | i::xs’ &#x3D;&gt; f(xs’,i+acc)
    in
    	f(xs,0)
    end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个函数计算的结果是一样的，但是<code>sum2</code>更复杂，它使用了一个本地辅助函数，需要一个额外的参数，叫做<code>acc</code>，代表”累加器”。在<code>f</code>的基本情况下，我们返回<code>acc</code>，最外层调用的值是<code>0</code>，与<code>sum1</code>的基本情况下使用的值相同。这种模式很常见：非累加器风格的基本情形成为初始累加器，累加器风格的基本情形只是返回累加器。</p>
<p>当<code>sum2</code>显然更复杂时，为什么会选择它呢？要回答这个问题，我们需要了解一点关于函数调用的实现方式。从概念上讲，有一个调用栈，它是一个堆栈（具有push和pop操作的数据结构），每个已经开始但尚未完成的函数调用（在其中）都有一个元素。每个元素都存储着诸如局部变量的值以及函数的哪一部分还没有被评估。当一个函数体的评估调用另一个函数时，一个新的元素被push到调用栈上，当被调用的函数完成时，它被pop。</p>
<p>所以对于<code>sum1</code>来说，每一次对<code>sum1</code>的递归调用都会有一个调用堆栈元素（有时只称为”栈帧”），也就是说，堆栈会和列表一样大。这是必要的，因为在弹出每个堆栈帧之后，调用者必须“完成正文的其余部分”——即将<code>i</code>添加到递归结果并返回。</p>
<p>鉴于到目前为止的描述，<code>sum2</code>也没有更好：<code>sum2</code>调用<code>f</code>，然后为每个列表元素进行一次递归调用。然而，当<code>f</code>对<code>f</code>进行递归调用时，在被调用者返回后，除了返回被调用者的结果外，调用者没有其他事情可做。这种情况被称为尾部调用（我们不要试图弄清楚为什么叫这个名字），像ML这样的函数式语言通常会承诺一个基本的优化。当一个调用是尾部调用时，调用者的堆栈框架在调用前被弹出——被调用者的栈帧只是取代了调用者的栈帧。这是有道理的：反正调用者只是要返回被调用者的结果。因此，对<code>sum2</code>的调用永远不会使用超过1个栈帧。</p>
<p>为什么函数式语言的实现包括这种优化？通过这样做，递归有时可以像while-loop一样高效，也不会使调用栈变大。这个”有时”是指当调用是尾部调用时，程序员可以对此进行推理，因为你可以看一下代码，确定哪些调用是尾部调用。</p>
<p>所有调用都不需要指向同一个函数（<code>f</code>可以调用<code>g</code>），所以比while-loops更灵活，因为后者总是要”调用”同一个循环。使用累加器是将递归函数变成”尾递归函数”（所有的递归调用都是尾部调用）的一种常见方式，但并不总是如此。例如，处理树（而不是列表）的函数通常有与树的深度一样大的调用栈，但这在任何语言中都是真实的：while-loops对于处理树来说不是很有用。</p>
<h2 id="更多尾递归示例"><a href="#更多尾递归示例" class="headerlink" title="更多尾递归示例"></a>更多尾递归示例</h2><p>尾递归在处理列表的函数中很常见，但这个概念更为普遍。例如，这里有两个阶乘函数的实现，其中第二个使用了尾递归的辅助函数，因此它只需要少量恒定的调用栈空间：</p>
<pre class="line-numbers language-none"><code class="language-none">fun fact1 n &#x3D; if n&#x3D;0 then 1 else n * fact1(n-1)

fun fact2 n &#x3D;
    let fun aux(n,acc) &#x3D; if n&#x3D;0 then acc else aux(n-1,acc*n)
    in
    	aux(n,1)
    end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>值得注意的是，<code>fact1 4</code>和<code>fact2 4</code>产生相同的答案，尽管前者执行$4 ∗(3 ∗ (2 ∗ (1*1))$，后者执行$(((1 ∗ 4) ∗ 3) ∗ 2) ∗ 1$。我们依靠的是乘法结合率的$(a∗(b∗c)=(a∗b)∗c)$和乘以1是同一函数$(1∗x=x∗1=x)$的事实。先前的sum例子对加法做了类似的假设。一般来说，将一个非尾递归函数转换为尾递归函数通常需要结合性，但许多函数都有结合性。</p>
<p>一个更有趣的例子是这个用于反转列表的低效函数：</p>
<pre class="line-numbers language-none"><code class="language-none">fun rev1 lst &#x3D;
   case lst of
       [] &#x3D;&gt; []
     | x::xs &#x3D;&gt; (rev1 xs) @ [x]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以立即意识到这不是尾递归，因为在递归调用之后，仍然要将结果附加到持有列表头部的单元素列表上。虽然这是最自然的反转列表的方法，但效率低下的原因不仅仅是创建一个深度等于参数长度的调用栈，我们将其称为$n$。更糟糕的问题是，所做的工作总量与$n^2$成正比，也就是说，这是一个二次时间复杂度算法。原因是追加两个列表需要的时间与第一个列表的长度成正比：它必须遍历第一个列表——见前面讨论的我们自己对append的实现。在对<code>rev1</code>的所有递归调用中，我们对长度为$n-1,n-2,…,1$的第一个参数调用<code>@</code>，从$1$到$n-1$的整数之和为$n∗(n-1)/2$。</p>
<p>正如你在数据结构和算法课程中所学到的，对于足够大的$n$来说，像这样的二次时间复杂度算法要比线性算法慢得多。这就是说，如果$n$总是很小，可能值得珍惜程序员的时间，坚持使用简单的递归算法。否则，幸运的是，使用累加器的习语会导致一个几乎同样简单的线性算法。</p>
<pre class="line-numbers language-none"><code class="language-none">fun rev2 lst &#x3D;
    let fun aux(lst,acc) &#x3D;
            case lst of
                [] &#x3D;&gt; acc
              | x::xs &#x3D;&gt; aux(xs, x::acc)
    in
        aux(lst,[])
	end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关键区别在于(1) 尾部递归和(2) 我们对每个递归调用只做了一个常量工作，因为<code>::</code>不需要遍历其任一参数。</p>
<h2 id="尾部位置的精确定义"><a href="#尾部位置的精确定义" class="headerlink" title="尾部位置的精确定义"></a>尾部位置的精确定义</h2><p>虽然大多数人依靠直觉来判断 “哪些调用是尾部调用”，但我们可以通过递归地定义尾部位置，并说如果一个调用处于尾部位置，它就是一个尾部调用。这个定义对每一种表达式都有定义，这里有几个部分：</p>
<ul>
<li>在<code>fun f(x) = e</code>中，e在尾部位置。</li>
<li>如果一个表达式不在尾部位置，那么它的所有子表达式都不在尾部位置。</li>
<li>如果<code>if e1 then e2 else e3</code>在尾部位置，那么<code>e2</code>和<code>e3</code>都在尾部位置（但不是<code>e1</code>）,（Case表达式类似）</li>
<li>如果<code>let b1 ... bn in e end</code>在尾部位置，那么<code>e</code>在尾部位置（但是绑定中没有表达式在尾部位置）。</li>
<li>函数调用参数不在尾部位置。</li>
<li>…</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Doraemonzzz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.doraemonzzz.com/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/">http://www.doraemonzzz.com/2022/02/28/2022-2-28-Programming-Languages-Part-A-Section2-%E7%BF%BB%E8%AF%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.doraemonzzz.com" target="_blank">Doraemonzzz</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Coursera-Programming-Languages/">Coursera Programming Languages</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/28/2022-2-28-Programming-Languages-Part-A-Week-4%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Programming Languages Part A Week 4笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/28/2022-2-28-Programming-Languages-Part-A-HW2-Extra-Practice-Problems/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Programming Languages Part A HW2 Extra Practice Problems</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/10/2022-1-10-Programming-Languages-Part-A-HW0/" title="Programming Languages Part A HW0"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">Programming Languages Part A HW0</div></div></a></div><div><a href="/2022/01/10/2022-1-10-Programming-Languages-Part-A-HW1/" title="Programming Languages Part A HW1"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">Programming Languages Part A HW1</div></div></a></div><div><a href="/2022/01/10/2022-1-10-Programming-Languages-Part-A-Week-1笔记/" title="Programming Languages Part A Week 1笔记"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">Programming Languages Part A Week 1笔记</div></div></a></div><div><a href="/2022/02/28/2022-2-28-Programming-Languages-Part-A-HW3-Extra-Practice-Problems/" title="Programming Languages Part A HW3 Extra Practice Problems"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-28</div><div class="title">Programming Languages Part A HW3 Extra Practice Problems</div></div></a></div><div><a href="/2022/03/13/2022-3-13-Programming-Languages-Part-A-Practice-Exam/" title="Programming Languages Part A Practice Exam"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-13</div><div class="title">Programming Languages Part A Practice Exam</div></div></a></div><div><a href="/2022/03/13/2022-3-13-Programming-Languages-Part-A-Exam/" title="Programming Languages Part A Exam"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-13</div><div class="title">Programming Languages Part A Exam</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNDcxOS8xMTI1Ng=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/%E5%A4%B4%E5%83%8F.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Doraemonzzz</div><div class="author-info__description">个人博客，主要记录有关机器学习，数学以及计算机科学的笔记</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">779</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">79</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Doraemonzzz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Doraemonzzz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/doraemon_zzz@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/291079982" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">暂无公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Coursera%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AF%BE%E7%A8%8B-%E7%AC%AC2%E8%8A%82%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Coursera编程语言课程 第2节总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%96%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5%E6%80%A7%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">构建新类型的概念性方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%EF%BC%9A%E2%80%9CEach-of%E2%80%9D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">记录：“Each-of”类型的另一种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%90%8D%E7%A7%B0-vs-%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%BD%AE%EF%BC%8C%E8%AF%AD%E6%B3%95%E7%B3%96%E5%92%8C%E5%85%83%E7%BB%84%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">1.4.</span> <span class="toc-text">根据名称 vs 根据位置，语法糖和元组的真相</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%91%E5%AE%9A%EF%BC%9A%E6%88%91%E4%BB%AC%E8%87%AA%E5%B7%B1%E7%9A%84%E2%80%9COne-of%E2%80%9D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">数据类型绑定：我们自己的“One-of”类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ML%E5%A6%82%E4%BD%95%E4%B8%8D%E6%8F%90%E4%BE%9B%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">1.6.</span> <span class="toc-text">ML如何不提供对数据类型值的访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ML%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9B%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%80%BC%E7%9A%84%E8%AE%BF%E9%97%AE%EF%BC%9ACase%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">ML如何提供对数据类型值的访问：Case表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9COne-of%E2%80%9D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9C%89%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">1.8.</span> <span class="toc-text">“One-of”类型的有用例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%BB%91%E5%AE%9A%E5%92%8CCase%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0%E7%9B%AE%E5%89%8D%E4%B8%BA%E6%AD%A2%EF%BC%8C%E5%87%86%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.9.</span> <span class="toc-text">数据类型绑定和Case表达式到目前为止，准确地描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8C%E4%B9%89%E8%AF%8D"><span class="toc-number">1.10.</span> <span class="toc-text">类型同义词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%92%8C%E9%80%89%E9%A1%B9%E6%98%AF%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.11.</span> <span class="toc-text">列表和选项是数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.12.</span> <span class="toc-text">多态数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Each-Of%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%80%BC%E7%BB%91%E5%AE%9A%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">1.13.</span> <span class="toc-text">Each-Of类型的模式匹配：关于值绑定的真相</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%8E%A8%E7%90%86"><span class="toc-number">1.14.</span> <span class="toc-text">题外话：类型推理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9A%E5%A4%9A%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.15.</span> <span class="toc-text">题外话：多态类型和等价类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.16.</span> <span class="toc-text">嵌套模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%89%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">1.17.</span> <span class="toc-text">嵌套模式的有用例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%EF%BC%9A%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AAcase"><span class="toc-number">1.18.</span> <span class="toc-text">可选的：函数绑定中的多个case</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.19.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92%E5%92%8C%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">1.20.</span> <span class="toc-text">尾递归和累加器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E5%B0%BE%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.21.</span> <span class="toc-text">更多尾递归示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BE%E9%83%A8%E4%BD%8D%E7%BD%AE%E7%9A%84%E7%B2%BE%E7%A1%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">1.22.</span> <span class="toc-text">尾部位置的精确定义</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/02/2023-1-2-Chapter-2-Asymptotic-Analysis%E7%AC%94%E8%AE%B0-Part-1-(Stanford-Machine-Learning-Theory)/" title="Chapter 2 Asymptotic Analysis笔记 Part 1 (Stanford Machine Learning Theory)"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 2 Asymptotic Analysis笔记 Part 1 (Stanford Machine Learning Theory)"/></a><div class="content"><a class="title" href="/2023/01/02/2023-1-2-Chapter-2-Asymptotic-Analysis%E7%AC%94%E8%AE%B0-Part-1-(Stanford-Machine-Learning-Theory)/" title="Chapter 2 Asymptotic Analysis笔记 Part 1 (Stanford Machine Learning Theory)">Chapter 2 Asymptotic Analysis笔记 Part 1 (Stanford Machine Learning Theory)</a><time datetime="2023-01-02T07:25:00.000Z" title="发表于 2023-01-02 15:25:00">2023-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/02/2023-1-2-Chapter-1-Supervised-Learning-Formulations%E7%AC%94%E8%AE%B0-(Stanford-Machine-Learning-Theory)/" title="Chapter 1 Supervised Learning Formulations笔记 (Stanford Machine Learning Theory)"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 1 Supervised Learning Formulations笔记 (Stanford Machine Learning Theory)"/></a><div class="content"><a class="title" href="/2023/01/02/2023-1-2-Chapter-1-Supervised-Learning-Formulations%E7%AC%94%E8%AE%B0-(Stanford-Machine-Learning-Theory)/" title="Chapter 1 Supervised Learning Formulations笔记 (Stanford Machine Learning Theory)">Chapter 1 Supervised Learning Formulations笔记 (Stanford Machine Learning Theory)</a><time datetime="2023-01-02T06:40:00.000Z" title="发表于 2023-01-02 14:40:00">2023-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/25/2022-12-25-ECE408-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8ALab-0/" title="ECE408 环境配置以及Lab 0"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ECE408 环境配置以及Lab 0"/></a><div class="content"><a class="title" href="/2022/12/25/2022-12-25-ECE408-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8ALab-0/" title="ECE408 环境配置以及Lab 0">ECE408 环境配置以及Lab 0</a><time datetime="2022-12-25T15:37:00.000Z" title="发表于 2022-12-25 23:37:00">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/25/2022-12-25-Softmax%E6%9E%81%E5%80%BC%E9%A1%B9%E5%85%B3%E4%BA%8E%E6%B8%A9%E5%BA%A6%E7%9A%84%E5%AF%BC%E6%95%B0/" title="Softmax极值项关于温度的导数"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Softmax极值项关于温度的导数"/></a><div class="content"><a class="title" href="/2022/12/25/2022-12-25-Softmax%E6%9E%81%E5%80%BC%E9%A1%B9%E5%85%B3%E4%BA%8E%E6%B8%A9%E5%BA%A6%E7%9A%84%E5%AF%BC%E6%95%B0/" title="Softmax极值项关于温度的导数">Softmax极值项关于温度的导数</a><time datetime="2022-12-25T05:02:00.000Z" title="发表于 2022-12-25 13:02:00">2022-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/2022-12-12-Deep-Learning-Systems-HW4/" title="Deep Learning Systems HW4"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Deep Learning Systems HW4"/></a><div class="content"><a class="title" href="/2022/12/12/2022-12-12-Deep-Learning-Systems-HW4/" title="Deep Learning Systems HW4">Deep Learning Systems HW4</a><time datetime="2022-12-12T14:05:00.000Z" title="发表于 2022-12-12 22:05:00">2022-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2023 By Doraemonzzz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.25
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'IpnmxCW9CvYWIXbol5QXsegX-MdYXbMMI',
      appKey: 'w57DVCdbxcyB1TYYagMIMJIU',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>