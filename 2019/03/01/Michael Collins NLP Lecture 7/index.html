<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Michael Collins NLP Lecture 7 | Doraemonzzz</title><meta name="keywords" content="Michael Collins NLP"><meta name="author" content="Doraemonzzz"><meta name="copyright" content="Doraemonzzz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="课程主页：http:&#x2F;&#x2F;www.cs.columbia.edu&#x2F;~cs4705&#x2F; 课程网盘地址： 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1KijgO7yjL_MVCC9zKZ7Jdg提取码：t1i3  这一讲主要介绍了机器翻译。">
<meta property="og:type" content="article">
<meta property="og:title" content="Michael Collins NLP Lecture 7">
<meta property="og:url" content="http://www.doraemonzzz.com/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/index.html">
<meta property="og:site_name" content="Doraemonzzz">
<meta property="og:description" content="课程主页：http:&#x2F;&#x2F;www.cs.columbia.edu&#x2F;~cs4705&#x2F; 课程网盘地址： 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1KijgO7yjL_MVCC9zKZ7Jdg提取码：t1i3  这一讲主要介绍了机器翻译。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2019-03-01T12:07:00.000Z">
<meta property="article:modified_time" content="2020-05-07T03:40:20.984Z">
<meta property="article:author" content="Doraemonzzz">
<meta property="article:tag" content="Michael Collins NLP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="https://github.com/Doraemonzzz/md-photo/blob/master/%E5%A4%B4%E5%83%8F.jpg?raw=true"><link rel="canonical" href="http://www.doraemonzzz.com/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?6f00f37f957f0608abb8c571105456f0";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-G-RE4B1LKRZD"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-G-RE4B1LKRZD');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离上次更新已经","messageNext":"天了，文章内容可能已经过时。"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Michael Collins NLP Lecture 7',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-05-07 11:40:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/bilibili.css" media="defer" onload="this.media='all'"><meta name="google-site-verification" content="c4v-NmuUZRgl3cvtg9GKswryK1YLaPztd_5M-df5VNI" /><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Doraemonzzz" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/%E5%A4%B4%E5%83%8F.jpg?raw=true" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">621</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-chart-pie"></i><span> 博客统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/charts/"><i class="fa-fw far fa-chart-bar"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/census/"><i class="fa-fw fas fa-chart-area"></i><span> 访问统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/top/"><i class="fa-fw fab fa-hotjar"></i><span> 阅读排行榜</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Doraemonzzz</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-chart-pie"></i><span> 博客统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/charts/"><i class="fa-fw far fa-chart-bar"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/census/"><i class="fa-fw fas fa-chart-area"></i><span> 访问统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/top/"><i class="fa-fw fab fa-hotjar"></i><span> 阅读排行榜</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Michael Collins NLP Lecture 7</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-03-01T12:07:00.000Z" title="发表于 2019-03-01 20:07:00">2019-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-05-07T03:40:20.984Z" title="更新于 2020-05-07 11:40:20">2020-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NLP/">NLP</a></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Michael-Collins-NLP/">Michael Collins NLP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="leancloud_visitors" id="/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/" data-flag-title="Michael Collins NLP Lecture 7"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>课程主页：<a target="_blank" rel="noopener" href="http://www.cs.columbia.edu/~cs4705/">http://www.cs.columbia.edu/~cs4705/</a></p>
<p>课程网盘地址：</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1KijgO7yjL_MVCC9zKZ7Jdg">https://pan.baidu.com/s/1KijgO7yjL_MVCC9zKZ7Jdg</a><br>提取码：t1i3 </p>
<p>这一讲主要介绍了机器翻译。</p>
<span id="more"></span>
<h2 id="Chapter-5-统计机器翻译：IBM模型1和2"><a href="#Chapter-5-统计机器翻译：IBM模型1和2" class="headerlink" title="Chapter 5 统计机器翻译：IBM模型1和2"></a>Chapter 5 统计机器翻译：IBM模型1和2</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>接下来的几个课程讲座将侧重于机器翻译，特别是统计机器翻译（SMT）系统。 在本讲义中，我们将重点介绍IBM翻译模型，这些模型可以追溯到20世纪80年代末/90年代初期。 这些模型是开创性的，是当今使用的许多SMT模型的基础。</p>
<p>​    遵循惯例，我们将在整个讲义中假设任务是将法语（““源”语言）翻译成英语（“目标”语言）。 一般来说，我们用$f$来表示法语句子：$f$是单词序列$f_1,f_2…f_m$，其中$m$是句子的长度，$f_j$表示句子中的第$j$个单词（$j\in \{1…m\}$）。我们用$e$来表示英文句子：$e$等于$e_1, e_2 …e_l$，其中$l$是英语句子的长度。</p>
<p>​    在SMT系统中，我们假设我们有一组样本翻译，$(f^{(k)},e^{(k)})$，$k=1…n$，其中$f^{(k)}$是训练样本中的第$k$个法语句子，$e^{(k)}$是第$k$个英语句子，并且$e^{(k)}$是$f^{(k)} $的翻译。 每个$f^{(k)}$等于$f^{(k)}_1…f^{(k)}_{m_k}$，其中$m_k$是第$k$个法语句子的长度。 每个$e^{(k)}$等于$e^{(k)}_1…e^{(k)}_{l_k}$，其中$l_k$是第$k$个英语句子的长度。我们将从这些训练样本中估计模型的参数。</p>
<p>​    那么我们从哪里获得训练样本？ 事实证明，很多语言对都有相当大的翻译样本。 最初的IBM工作，实际上专注于从法语到英语的翻译，利用加拿大议会的会议记录（Hansards）：他们使用的语料库由数百万个翻译句子组成。 Europarl数据包括来自欧洲议会的会议记录，包括几种欧洲语言之间的翻译。 其他语料库存在阿拉伯语——英语，中文——英文等翻译。</p>
<h3 id="2-噪声通道方法"><a href="#2-噪声通道方法" class="headerlink" title="2.噪声通道方法"></a>2.噪声通道方法</h3><p>在几个讲座之前，我们介绍了生成模型，特别是噪声通道方法。IBM模型是噪声通道模型的实例，因此它们有两个组件：</p>
<ol>
<li>一个语言模型，它用于为任何英语中的句子$e=e_1…e_l$指定概率$p(e)$。例如，我们将为模型的这一部分使用三元语言模型。可以从非常大量的英语数据中估计语言模型的参数。</li>
<li>一个翻译模型，它将条件概率$p(f|e)$分配给任何法语/英语句子。将根据翻译样本估计此模型的参数。该模型涉及两个选择，两个选择都以英语句子$e_1…e_l$为条件；首先选择法语句子的长度$m$；第二，选择$m$个单词$f_1…f_m$。</li>
</ol>
<p>​    给定模型的这两个组件，遵循噪声通道方法中的常用方法，翻译模型对新法语句子$f$上的输出是：</p>
<script type="math/tex; mode=display">
e^* =\arg \max_{e\in E} p(e) \times p(f|e)</script><p>其中$E$是所有英语句子的集合。 因此，可能的翻译$e$的得分是两个分数的乘积：第一，语言模型的分数$p(e)$，其给出了用英语表示句子的先验分布；第二，翻译模型的分数$p(f|e) $，表示我们将法语句子$f$视为$e$的翻译的可能性。</p>
<p>​    请注意，正如噪声通道模型中通常的那样，模型$p(f|e)$似乎也是“反向”（backwards）的：尽管我们正在构建从法语到英语的翻译模型，我们有一个$p(f|e)$模型。噪声通道方法使用了贝叶斯法则：</p>
<script type="math/tex; mode=display">
p(e|f) =\frac{p(e)p(f|e)}{\sum_e p(e)p(f|e)}</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned}
\arg\max_{e\in E} p(e|f)
&=\arg\max_{e\in E} \frac{p(e)p(f|e)}{\sum_e p(e)p(f|e)}\\
&=\arg\max_{e\in E}p(e)p(f|e)
\end{aligned}</script><p>噪声通道方法的一个主要好处是它允许我们使用语言模型$p(e)$。 这对于提高翻译模型输出的流畅性或语法性非常有用。</p>
<p>​    本讲义的其余部分将重点关注以下问题：</p>
<ul>
<li>我们如何定义翻译模型$p(f|e)$？</li>
<li>如何从训练样本$(f^{(k)}, e^{(k)})$中估计的翻译模型的参数$(k=1…n)$？</li>
</ul>
<p>​    我们将针对此问题描述IBM模型（特别是IBM模型1和2）。IBM模型是SMT的早期方法，现在没有被广泛用于翻译：改进的模型（我们将在下一讲中介绍）已经在最近的工作中得到。 但是，它们（IBM模型）对我们非常有用，原因如下：</p>
<ol>
<li>模型直接使用对齐（alignment）的概念，因此我们可以恢复训练数据中法语和英语单词之间的对齐。由此产生的对齐模型在现代SMT系统中至关重要。</li>
<li>将使用期望最大化（EM）算法估计IBM模型的参数。EM算法被广泛用于NLP和其他问题域的统计模型。 我们将在课程后期深入研究它：我们使用此处描述的IBM模型作为该算法的第一个示例。</li>
</ol>
<h3 id="3-IBM模型"><a href="#3-IBM模型" class="headerlink" title="3.IBM模型"></a>3.IBM模型</h3><h4 id="3-1-对齐（Alignments）"><a href="#3-1-对齐（Alignments）" class="headerlink" title="3.1 对齐（Alignments）"></a>3.1 对齐（Alignments）</h4><p>我们现在转向为任何法语句子建立条件概率$p(f|e ) $的问题，其中法语句子$f=f_1…f_m$与英语句子$e=e_1…e_l$组成一对。<br>    回想一下$p(f|e) $涉及两个选择：第一，选择法语句子的长度$m$；第二，选择单词$f_1…f_m$。我们将假设存在某个分布$p(m|l)$，该分布对法语句子长度关于英语句子长度的条件分布建模。从现在开始，我们将长度$m$固定，我们的重点将放在对如下分布的建模上</p>
<script type="math/tex; mode=display">
p(f_1...f_m| e_1...e_l,m)</script><p>即，单词$f_1…f_m$关于英语字符串$e_1…e_l$以及法语句子长度$m$的条件概率。</p>
<p>​    直接模拟$p(f_1…f_m| e_1…e_l,m)$是非常困难的。IBM模型的一个中心思想是为问题引入额外的对齐变量。 我们将有对齐变量$a_1…a_m$——也就是说，为句子中每个法语单词指定一个对齐变量——其中每个对齐变量可以取$\{0,1,…,l\}$中的任何值。对齐变量将指定每个法语单词与英语句子中某个单词的对齐。</p>
<p>​    我们不是试图直接定义$p(f_1…f_m| e_1…e_l,m)$，而是关于法语句子$f_1…f_m$以及对其变量$a_1…a_m$定义一个条件分布</p>
<script type="math/tex; mode=display">
p(f_1...f_m,a_l...a_m| e_1...e_l,m)</script><p>定义了这个模型后，我们可以通过对齐变量求和来计算$p(f_1…f_m| e_1…e_l,m)$（“边缘化”对齐变量）：</p>
<script type="math/tex; mode=display">
p(f_1...f_m| e_1...e_l,m) = \sum_{a_1=0}^ l \sum_{a_2=0}^ l
 \sum_{a_3=0}^ l... \sum_{a_m=0}^ l p(f_1...f_m,a_l...a_m| e_1...e_l,m)</script><p>​    我们现在详细描述对齐变量。每个对齐变量$a_j$指定法语单词$f_j$与英语单词$e_{a_j}$对齐：我们将很快直观地看到，在概率模型中，单词$f_j$将从英语单词$e_{a_j}$生成。 我们将$e_0$定义为一个特殊的单词$\text{NULL}$；所以$a_j =0$指定从单词$\text{NULL}$生成的单词$f_j $。 我们将在描述概率模型时看到$\text{NULL}$符号所扮演的角色。</p>
<p>​    作为一个例子，考虑$l=6,m=7$以及</p>
<script type="math/tex; mode=display">
\begin{aligned}
e &=\text{And the programme has been implemented}\\
f&= \text{Le programme a ete mis en application}
\end{aligned}</script><p>在这种情况下，法语句子的长度$m$等于$7$；因此我们有对齐变量$a_1,a_2,…,a_7$。 作为一个对齐（这是非常合理的），我们有</p>
<script type="math/tex; mode=display">
a_1,a_2,...,a_7 = \langle 2,3,4,5,6,6,6 \rangle</script><p>指定以下对齐方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Le} &\Rightarrow \text{the} \\
\text{Programme} &\Rightarrow \text{program} \\
\text{a} &\Rightarrow \text{has} \\
\text{ete} &\Rightarrow \text{been}\\
\text{mis} &\Rightarrow \text{implemented}\\
\text{en} &\Rightarrow \text{implemented}\\
\text{application} &\Rightarrow \text{implemented}\\
\end{aligned}</script><p>请注意，每个法语单词都与一个英语单词对齐。 对齐是多对一的：可以将多个法语单词与一个英语单词对齐（例如，mis，en和application都与implemented对齐）。某些英语单词可能不与法语单词对齐：例如单词And与此示例中的任何法语单词都不对齐。</p>
<p>​    还要注意，该模型是不对称的，因为没有约束条件规定每个英语单词恰好与一个法语单词对齐：每个英语单词可以与任何数字（零个或多个）法语单词对齐。 我们稍后会回到这一点。</p>
<p>​    作为另一个对齐示例，我们有</p>
<script type="math/tex; mode=display">
a_1,a_2,...,a_7 = \langle 1,1,1,1,1,1,1 \rangle</script><p>指定以下对齐方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Le} &\Rightarrow \text{And} \\
\text{Programme} &\Rightarrow  \text{And} \\
\text{a} &\Rightarrow  \text{And} \\
\text{ete} &\Rightarrow  \text{And}\\
\text{mis} &\Rightarrow  \text{And}\\
\text{en} &\Rightarrow  \text{And}\\
\text{application} &\Rightarrow  \text{And}\\
\end{aligned}</script><p>对于这个例子，这显然不是一个好的对齐方式。</p>
<h4 id="3-2-对齐模型：IBM模型2"><a href="#3-2-对齐模型：IBM模型2" class="headerlink" title="3.2 对齐模型：IBM模型2"></a>3.2 对齐模型：IBM模型2</h4><p>我们现在描述如下条件概率的模型</p>
<script type="math/tex; mode=display">
p(f_1...f_m,a_l...a_m| e_1...e_l,m)</script><p>我们描述的模型通常被称为IBM模型2：我们将使用IBM-M2作为此模型的简写。 稍后我们将描述IBM模型1是IBM模型2的特例。模型的定义如下：</p>
<h6 id="定义-1（IBM模型2）"><a href="#定义-1（IBM模型2）" class="headerlink" title="定义 1（IBM模型2）"></a>定义 1（IBM模型2）</h6><p>IBM-M2模型由英语单词的有限集合$\mathcal E$，法语单词集合$\mathcal F$，以及指定法语和英语句子的最大长度的整数$M$和$L$组成。 该模型的参数如下：</p>
<ul>
<li>$t(f|e)$，对任何$f\in \mathcal F,e \in \mathcal E \cup \{\text{NULL}\}$。 参数$t(f|e)$可以解释为由英语单词$e$生成法语单词$f$的条件概率。</li>
<li>$q(j|i,l,m)$对于任何$l\in \{1…L\},m\in \{1…M\}, i \in \{1…m\},j \in \{0…l\}$。 参数$q(j|i,l,m)$可以解释为给定英语和法语句子的长度$l$和$m$，对齐变量$a_i$取值$j$的概率。</li>
</ul>
<p>给定这些定义，对于任何英语句子$e_1…e_l$，其中每个$e_j \in \mathcal E$，对于每个长度$m$，我们定义关于法语句子$f_1…f_m$以及对其变量$a_1…a_m$的条件概率为</p>
<script type="math/tex; mode=display">
p(f_1...f_m,a_l...a_m| e_1...e_l,m)
=\prod_{i=1}^m q(a_i|i,l,m)t(f_i|e_{a_i})</script><p>这里我们定义$e_0$为单词$\text{NULL}$。</p>
<p>​    为了说明这个定义，考虑前面的例子，其中$l=6,m=7$以及</p>
<script type="math/tex; mode=display">
\begin{aligned}
e &=\text{And the programme has been implemented}\\
f&= \text{Le programme a ete mis en application}
\end{aligned}</script><p>对齐变量为</p>
<script type="math/tex; mode=display">
a_1,a_2,...,a_7 = \langle 2,3,4,5,6,6,6 \rangle</script><p>指定以下对齐方式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{Le} &\Rightarrow \text{the} \\
\text{Programme} &\Rightarrow \text{program} \\
\text{a} &\Rightarrow \text{has} \\
\text{ete} &\Rightarrow \text{been}\\
\text{mis} &\Rightarrow \text{implemented}\\
\text{en} &\Rightarrow \text{implemented}\\
\text{application} &\Rightarrow \text{implemented}\\
\end{aligned}</script><p>在这个情形下，我们有</p>
<script type="math/tex; mode=display">
\begin{aligned}
&p(f_1...f_m,a_l...a_m| e_1...e_l,m) \\
=& q(2|1,6,7)\times t(\text{Le}|\text{the}) \\
&\times q(3|2,6,7)\times t(\text{programme}|\text{program})\\
&\times q(4|3,6,7)\times t(\text{a}|\text{has})\\
&\times q(5|4,6,7)\times t(\text{ete}|\text{been})\\
&\times q(6|5,6,7)\times t(\text{mis}|\text{implemented})\\
&\times q(6|6,6,7)\times t(\text{en}|\text{implemented})\\
&\times q(6|7,6,7)\times t(\text{application}|\text{implemented})\\
\end{aligned}</script><p>​    因此，每个法语单词都有两个相关项：第一，选择对齐变量，指定单词与哪个英语单词对齐；第二，根据步骤1中选择的英语单词选择法语单词。例如，对于$f_5=\text{mis}$，我们首先选择$a_5 = 6$，概率为$q(6|5,6,7)$，然后选择单词$\text{mis}$，基于英语单词$e_6 =\text{implemented}$，概率为$t(\text{mis}|\text{implemented})$。<br>​    注意，对齐参数$q(j|i,l,m)$对每个三元组$i,j,m$指定不同的分布$\langle q(0|i,l,m) ,q(1|i,l,m)…q(l|i,l,m)\rangle$，其中$i$是法语句子中的位置，$l$是英语句子的长度，$m$是法语句子的长度。例如，这将使我们能够捕捉到接近法语句子开头的单词倾向于接近英语句子开头的单词的翻译。</p>
<p>​    这个模型当然相当简单和朴素。 但是，它捕获了数据的一些重要方面。</p>
<h4 id="3-3-IBM模型2中的独立假设"><a href="#3-3-IBM模型2中的独立假设" class="headerlink" title="3.3 IBM模型2中的独立假设"></a>3.3 IBM模型2中的独立假设</h4><p>我们现在考虑IBM模型2的独立假设。将$L$作为与英语句子长度相对应的随机变量；$E_1…E_l$是与英语句子中的单词对应的随机变量序列；$M$是对应于法语句子长度的随机变量；$F_1…F_m$和$A_1…A_m$是法语m单词序列和对齐变量。 我们的目标是建立一个模型</p>
<script type="math/tex; mode=display">
P(F_1=f_1...F_m=f_m,A_1=a_1...A_m=a_m|
E_1=e_1...E_l = e_l,L=l,M=m)</script><p>作为第一步，我们可以使用概率的链式法则将其分解为两项：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&P(F_1=f_1...F_m=f_m,A_1=a_1...A_m=a_m|
E_1=e_1...E_l = e_l,L=l,M=m) \\
=& P(A_1=a_1...A_m=a_m|
E_1=e_1...E_l = e_l,L=l,M=m) \\
&\times P(F_1=f_1...F_m=f_m|A_1=a_1...A_m=a_m,
E_1=e_1...E_l = e_l,L=l,M=m)
\end{aligned}</script><p>我们现在将分别考虑这两项。<br>    首先，我们做出以下独立假设：</p>
<script type="math/tex; mode=display">
\begin{aligned}

&P(A_1=a_1...A_m=a_m|
E_1=e_1...E_l = e_l,L=l,M=m) \\
=&\prod_{i=1}^m P(A_i=a_i|
A_1=a_1...A_{i-1}=a_{i-1},E_1=e_1...E_l = e_l,L=l,M=m) \\
=&\prod_{i=1}^m  P(A_i =a_i|L=l,M=m)
\end{aligned}</script><p>第一个等号是由概率的链式法则。 第二个等号对应于一个非常强的独立性假设：即，随机变量$A_i$的分布仅取决于随机变量$L$和$M$的值（它独立于英语单词$E_1…E_l $，以及其他对齐变量）。 最后，我们假设</p>
<script type="math/tex; mode=display">
P(A_i =a_i|L=l,M=m) =q(a_i|i,l,m)</script><p>其中每个$q(a_i|i,l,m)$是我们模型的参数。</p>
<p>​    接着，我们做出以下假设：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&P(F_1=f_1...F_m=f_m|A_1=a_1...A_m=a_m,
E_1=e_1...E_l = e_l,L=l,M=m) \\
=& \prod_{i=1}^m P(F_i=f_i|F_1=f_1...F_{i-1}=f_{i-1},A_1=a_1...A_m=a_m,
E_1=e_1...E_l = e_l,L=l,M=m) \\
=&\prod_{i=1}^m P(F_i=f_i|E_{a_i} =e_{a_i})
\end{aligned}</script><p>第一个等号是由概率的链式法则。 在第二步中，我们假设$F_i$的值仅取决于$E_{a_i}$：即，取决于$F_i $对齐的英语单词的标识。 最后，我们假设对于所有$i$，</p>
<script type="math/tex; mode=display">
P(F_i=f_i|E_{a_i} =e_{a_i}) = t(f_i|e_{a_i})</script><p>其中每个$ t(f_i|e_{a_i})$是我们模型的参数。</p>
<h3 id="4-应用IBM模型2"><a href="#4-应用IBM模型2" class="headerlink" title="4.应用IBM模型2"></a>4.应用IBM模型2</h3><p>下一节将介绍IBM模型2的参数估计算法。在此之前，我们首先考虑一个重要问题：IBM模型2什么有用？</p>
<p>​    最初的动机是完整的机器翻译问题。 一旦我们从数据中估计了参数$q(j|i,l,m)$和$t(f|e)$，我们就得到了一个关于语法句子$f$，对齐序列$a$和英语句子$e$的分布</p>
<script type="math/tex; mode=display">
p(f,a|e)</script><p>从这里我们可以得到一个分布</p>
<script type="math/tex; mode=display">
p(f|e) = \sum_{a}p(f,a|e)</script><p>最后，假设我们有一个语言模型$p(e )$，我们可以定义任何法语句子$f$的翻译为</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
\arg \max_e p(e) p(f|e) \tag {1}
\end{eqnarray*}</script><p>其中$\arg\max$作用于所有可能的英语句子。 在公式1中找到$\arg\max$的问题通常被称为解码问题。 解决解码问题是计算上非常困难的问题，但是已经导出了各种近似方法。<br>    但实际上，IBM模型2并不是一个特别好的翻译模型。 在后面的讲座中，我们将看到远远更有效的模型。</p>
<p>​    然而，IBM模型在现代翻译系统中仍然至关重要，原因有两个：</p>
<ol>
<li>词汇概率$t(f|e) $直接用于各种翻译系统。 </li>
<li>最重要的是，使用IBM模型得出的对齐直接用于构建现代翻译系统。</li>
</ol>
<p>让我们更详细地考虑第二点。 假设我们已经从训练语料库中估计了我们的参数$t(f|e )$和$q(j|i,l,m)$（使用下一节中描述的参数估计算法）。给定任何由英语句子$e$与配对的法语句子$f$组成的训练样本，我们可以在模型下找到最可能的对齐：</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
\arg \max_{a_1...a_m} p(a_1...a_m|f_1...f_m, e_1...e_l,m)  \tag 2
\end{eqnarray*}</script><p>因为模型采用简单的形式，所以找到公式2的解很简单。 事实上，一个简单的推导表明我们只是对$i=1…m$定义</p>
<script type="math/tex; mode=display">
a_i =\arg \max_{j\in \{0...l\}} 
(q(j|i,l,m)\times t(f_i|e_j))</script><p>因此，对于每个法语单词$i$，我们简单地将其与英语位置$j$对齐，这使得两项的乘积最大化：第一，对齐概率$q(j|i,l,m)$; 第二，翻译概率$t(f_i|e_j)$。</p>
<h3 id="5-参数估计"><a href="#5-参数估计" class="headerlink" title="5.参数估计"></a>5.参数估计</h3><p>本节描述了从翻译数据估计参数$t(f|e)$和$q(j|i,l,m)$的方法。我们考虑两种情况：第一种是用完全观察到的数据估计；第二种是用部分观察到的数据估计。 第一种情况是不现实的，但在我们进入第二种更现实的情况之前，这将是一次有用的热身。</p>
<h4 id="5-1-具有完全观测数据的参数估计"><a href="#5-1-具有完全观测数据的参数估计" class="headerlink" title="5.1 具有完全观测数据的参数估计"></a>5.1 具有完全观测数据的参数估计</h4><p>我们现在转向以下问题：我们如何估计模型的参数$t(f|e)$和$q(j|i,l,m)$？我们假设有一个训练语料库，其中翻译为$\{f^{(k)},e^{(k)}\}_{k=1}^n$。但请注意，此数据中缺少一条关键信息：我们不知道每个训练样本的潜在的对齐方式。在这个意义上，我们将说数据只是部分观察到的，因为缺少一些信息——即每个句子的对齐。因此，我们经常将对齐变量称为隐藏变量。尽管存在隐藏变量，我们将看到我们实际上可以估计模型的参数。<br>    请注意，我们可能会雇佣人来给数据加上潜在的对齐（以类似的方式雇佣人来注释潜在的解析树，以形成树库资源）。但是，我们希望避免这种情况，因为对齐的手动注释将是一项昂贵的任务，合理大小的翻译语料库就需要花费大量时间来进行——而且，每次我们收集新的语料库时，我们都必须以这种方式对其进行注释。</p>
<p>​    在本节中，作为部分观测数据情况的预热，我们将考虑完全观测数据的情况，其中每个训练样本实际上确实包含三元组$(f^{(k)},e^{(k)},a^{(k)})$，其中$f^{(k)}=f^{(k)}_1….f^{(k)}_{m_k}$是法语句子，$e^{(k)}=e^{(k)}_1…e^{(k)}_{l_k}$是英语句子，$a^{(k)}=a^{(k)}_1…a^{(k)}_{m_k}$是对齐变量。 解决这种情况将有助于开发部分观测数据的算法。</p>
<p>​    完全观测到的数据的估计很容易推导出来。 将$c(e,f)$定义为单词$e$与训练数据中的单词$f$对齐的次数，$c(e)$是$e$与任何法语单词对齐的次数。 另外，将$c(j|i,l,m)$定义为我们同时看到长度为$l$的英语句子以及长度为$m$的法语句子的次数，其中法语中的单词$i$与英语中的单词$j$对齐。 最后，将$c(i,l,m)$定义为我们同时看到长度为$l$的英语句子和长度为$m$的法语句子的次数。 那么最大似然估计是</p>
<script type="math/tex; mode=display">
\begin{aligned}
t_{ML}(f|e) &=\frac{c(e,f)}{c(e)} \\
q_{ML}(j|i,l,m)& = \frac{c(j|i,l,m)}{c(i,l,m)}
\end{aligned}</script><p>因此，为了估计参数，我们只需从训练语料库中统计计数，然后获取这些计数的比值。<br>    图1显示了使用完全观测到的数据进行参数估计的算法。部分观测数据的算法将是该算法的直接修改。 算法考虑语料库中所有可能对齐的法语/英语单词对：即所有可能的$(k,i,j)$元组，其中$k\in \{1…n\},i\in \{1…m_k\},j\in\{0…l_k\}$。 对于每对单词，如果两个单词对齐，我们有$a_i^{(k)}=j$。 在这种情况下，我们增加相关的计数$c(e,f),c(e),c(j|i,l,m),c(i,l,m)$。 如果$a_i^{(k)}\neq j$，那么这两个单词不对齐，计数不增加。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/20190220.jpg?raw=true" alt=""></p>
<h4 id="5-2-部分观测数据的参数估计"><a href="#5-2-部分观测数据的参数估计" class="headerlink" title="5.2 部分观测数据的参数估计"></a>5.2 部分观测数据的参数估计</h4><p>我们现在考虑部分观测数据的情况，其中在训练语料库中没有观察到对齐变量$a^{(k)}$。 这种情况的算法如图2所示。该算法与图1中的算法有两个重要区别：</p>
<ul>
<li><p>该算法是迭代的。 我们从参数$t$和$q$的一些初始值开始：例如，我们可以将它们初始化为随机值。 在每次迭代时，我们首先根据数据和我们当前的参数估计值计算一些“计数”$c(e,f),c(e),c(j|i,l,m),c(i,l,m)$。然后我们使用这些计数重新估计参数，并迭代。</p>
</li>
<li><p>使用与图1中相似的定义计算计数，但有一个关键的区别：不是定义</p>
<script type="math/tex; mode=display">
\delta(k,i,j)=\begin{cases}
1 & a_i^{(k)}=j\\
0& 其他
\end{cases}</script><p>我们使用如下定义</p>
<script type="math/tex; mode=display">
\delta(k,i,j) =\frac{q(j|i,l_k,m_k)t(f_i^{(k)}|e_j^{(k)})}
{\sum_{j=0}^{l_k}q(j|i,l_k,m_k)t(f_i^{(k)}|e_j^{(k)})}</script><p>其中$q$和$t$是我们当前的参数估计值。</p>
</li>
</ul>
<p>​    让我们更详细地考虑这个最后的定义。 事实上，我们可以得到如下等式：</p>
<script type="math/tex; mode=display">
P(A_i=j|e_1...e_l, f_1...f_m,m)=\frac{q(j|i,l_k,m_k)t(f_i|e_j)}
{\sum_{j=0}^{l_k}q(j|i,l_k,m_k)t(f_i|e_j)}</script><p>其中$P(A_i=j|e_1…e_l, f_1…f_m,m)$是在当前模型参数下对齐变量$a_i$取值$j$的条件概率。 因此，我们使用当前的参数估计有效地填充了对齐变量。 这与完全观测到的情况形成对比，其中我们可以简单地定义$\delta(k,i,j) 1=$如果$a_i^{(k)}=j$，否则为$0$。</p>
<p>​    作为一个例子，其中$l=6,m=7$以及</p>
<script type="math/tex; mode=display">
\begin{aligned}
e &=\text{And the programme has been implemented}\\
f&= \text{Le programme a ete mis en application}
\end{aligned}</script><p>此例子中$\delta(k,5,6)$的值将是当前模型对单词$f_5$与单词$e_6$对齐的概率的估计。 它的计算方法是</p>
<script type="math/tex; mode=display">
\frac{q(6|5,6,7)t(\text{mis}|\text{implemented})}
{\sum_{j=0}^{6}q(j|5,6,7)t(\text{mis}|e_j)}</script><p>因此，分子将翻译参数$t(\text{mis}|\text{implemented}) $与对齐参数$q(6|5,6,7)$一起考虑在内; 分母为关于每个英语单词求和。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2019022001.jpg?raw=true" alt=""></p>
<p>​    图2中的算法是期望最大化（EM）算法的实例。 在部分观测数据的情况下，EM算法被广泛用于参数估计。 $c(e),c(e,f)$计数等被称为期望计数，因为它们是由如下分布定义的有效期望计数</p>
<script type="math/tex; mode=display">
p(a_1...a_m|f_1...f_m, e_1...e_l,m)</script><p>在每次迭代的第一步中，我们计算模型下的期望计数。在第二步中，我们使用这些预期计数来重新估计参数$t$和$q$。 我们迭代这个两步，直到参数收敛（这通常几次迭代后就会发生）。</p>
<h3 id="6-有关EM算法的更多信息：最大似然估计"><a href="#6-有关EM算法的更多信息：最大似然估计" class="headerlink" title="6. 有关EM算法的更多信息：最大似然估计"></a>6. 有关EM算法的更多信息：最大似然估计</h3><p>很快我们将在一些简单数据上跟踪EM算法的运行。 但首先，我们将考虑以下问题：我们如何证明算法的合理性？ 它的正式保证是什么，它优化的函数是什么？<br>    在本节中，我们将描述EM算法如何尝试查找数据的最大似然估计。 为此，我们需要引入一些符号，特别是，我们需要仔细指定IBM模型2的最大似然估计的确切含义。<br>    首先，考虑模型的参数。 有两种类型的参数：翻译参数$t(f|e)$和对齐参数$q(j|i,l,m)$。 我们将使用$t$来代表翻译参数的向量，</p>
<script type="math/tex; mode=display">
t=\{t(f|e): f\in F,e\in E\bigcup \{\text{NULL}\}\}</script><p>$q$代表对齐参数的向量</p>
<script type="math/tex; mode=display">
q=\{q(j|i,l,m):
l\in \{1...L\},
m\in \{1...M\},
j\in \{0...l\},
i\in \{1...m\}
\}</script><p>我们将使用$\mathcal T$来代表翻译参数的参数空间——即翻译参数的有效集合，定义如下：</p>
<script type="math/tex; mode=display">
\mathcal T =
\{
t:\forall e,t, t(f|e)\ge 0;
\forall e\in E\bigcup \{\text{NULL}\},
\sum_{f\in F} t(f|e)=1
\}</script><p>我们将使用$\mathcal Q$来代表对齐参数的参数空间，</p>
<script type="math/tex; mode=display">
\mathcal Q=\{
 q:\forall j,i,l,m,q(j|i,l,m)\ge 0;
 \forall i,l,m,\sum_{j=0}^l q(j|i,l,m)=1
\}</script><p>​    接下来，考虑模型的概率分布。 这取决于参数集$t$和$q$。 我们将引入使这种依赖显式化的符号。 我们将</p>
<script type="math/tex; mode=display">
p(f,a|e,m;t,q) = \prod_{i=1}^m q(a_i |i,l,m)t(f_i|e_{a_i})</script><p>作为法语句子$f_1…f_m $，带有对齐变量$a_1…a_m $，关于英语句子$e_1…e_l $和法语句子长度$m$的条件概率。 函数$p(f,a|e,m;t,q)$随着参数向量$t$和$q$的变化而变化，并且我们通过在该表达式中的“;”之后包括$t$和$q$来明确这种依赖性。</p>
<p>​    如前所述，我们还有以下分布：</p>
<script type="math/tex; mode=display">
p(f|e,m;t,q) =\sum_{a\in \mathcal A(l,m)}
p(f,a|e,m;t,q)</script><p>其中$\mathcal A(l,m)$是对齐变量的所有可能的集合，假设英语句子的长度为$l$，而法语句子的长度为$m$：</p>
<script type="math/tex; mode=display">
\mathcal A(l,m) =
\{
(a_1...a_m); a_j \in \{0...l\},j=1...m
\}</script><p>所以$p(f|e,m;t,q)$是法语句子$f$关于以$e$和$m$的条件概率，其中参数为$t$和$q$。</p>
<p>​    现在考虑参数估计问题。 我们有以下假定：</p>
<ul>
<li>参数估计算法的输入是一组训练样本，$(f^{(k)},e^{(k)}),k=1…n$。</li>
<li>参数估计算法的输出是一对参数向量$t\in \mathcal T,q\in \mathcal Q$。</li>
</ul>
<p>那么我们应该如何选择参数$t$和$q$？ 我们首先考虑单个训练样本，$(f^{(k)},e^{(k)})$，对于某个$k\in \{1…n\}$。 对于任何参数$t$和$q$，我们可以考虑如下概率</p>
<script type="math/tex; mode=display">
p(f^{(k)} |e^{(k)},m_k;t,q)</script><p>当我们改变参数$t$和$q$时，这个概率会变化。 直观地说，一个好的模型会使这个概率尽可能高。 </p>
<p>​    现在考虑整个训练样本。 对于任何参数$t,q$，我们可以计算整个训练样本的概率，如下：</p>
<script type="math/tex; mode=display">
\prod_{k=1}^n p(f^{(k)} |e^{(k)},m_k;t,q)</script><p>同样，这个概率随着参数$t$和$q$的变化而变化；直觉上，我们想选择参数$t$和$q$，使这个概率尽可能高。 这导致以下定义：</p>
<h6 id="定义-2-（IBM模型2的最大似然估计（ML））"><a href="#定义-2-（IBM模型2的最大似然估计（ML））" class="headerlink" title="定义 2 （IBM模型2的最大似然估计（ML））"></a>定义 2 （IBM模型2的最大似然估计（ML））</h6><p>IBM模型2的最大似然估计为</p>
<script type="math/tex; mode=display">
(t_{ML},q_{ML}) = \arg \max_{t\in \mathcal T, q\in \mathcal Q}
L(t,q)</script><p>其中</p>
<script type="math/tex; mode=display">
\begin{aligned}
L(t,q)
& = \log \Big( \prod_{k=1}^n p(f^{(k)} |e^{(k)},m_k;t,q)\Big)\\
&=\sum_{k=1}^n \log  p(f^{(k)} |e^{(k)},m_k;t,q)\\
&=\sum_{k=1}^n \log \sum_{a\in \mathcal A(l_k,m_k)}
p(f^{(k)},a |e^{(k)},m_k;t,q)
\end{aligned}</script><p>我们将函数$L(t,q)$称为对数似然函数。</p>
<p>​    根据这个定义，ML估计被定义为最大化函数的量</p>
<script type="math/tex; mode=display">
\log \Big( \prod_{k=1}^n p(f^{(k)} |e^{(k)},m_k;t,q)\Big)</script><p>注意到这等价于最大化</p>
<script type="math/tex; mode=display">
\prod_{k=1}^n p(f^{(k)} |e^{(k)},m_k;t,q)</script><p>​    我们现在考虑正在优化的函数$L(t,q) $。 这实际上是一个难以处理的函数：首先，该优化问题没有解析解</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
(t,q) =\arg \max_{t\in \mathcal T, q\in \mathcal Q}
L(t,q) \tag 3
\end{eqnarray*}</script><p>通过解析解，我们指的是一种简单的封闭形式的解。作为解析解的一个例子，在语言建模中，我们发现三元参数的最大似然估计是</p>
<script type="math/tex; mode=display">
q_{ML}(w|u,v)
=\frac{\text{Count}(u,v,w)}{\text{Count}(u,v)}</script><p>遗憾的是，最大化公式3的参数没有类似的简单表达式。</p>
<p>​    第二个困难是$L(t,q)$不是凸函数。 图3展示了$x$是标量值（与向量相对）的函数$f(x)$的简单情况下凸函数和非凸函数的示例，其中。 凸函数具有单一的全局最优，并且直观地，简单的爬山算法将爬到这一点。 相比之下，图3中的第二个函数具有多个“局部”最优，并且直观地，爬山过程可能陷入局部最优，这不是全局最优。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2019022002.jpg?raw=true" alt=""></p>
<p>​    凸函数和非凸函数的正式定义超出了本讲义的范围。 然而，简而言之，有许多结果表明凸函数“易于”优化（即，我们可以设计找到$\arg\max$的有效算法），而非凸函数通常更难处理（即，我们可以经常表明，找到$\arg\max$在计算上很难，例如它通常是NP难的）。 在许多情况下，我们所希望的最好情形的是优化方法找到非凸函数的局部最优。<br>​    实际上，这正是模型2的EM算法的情况。它具有以下保证：</p>
<h6 id="定理-1-（IBM模型2的EM算法的收敛性）"><a href="#定理-1-（IBM模型2的EM算法的收敛性）" class="headerlink" title="定理 1 （IBM模型2的EM算法的收敛性）"></a>定理 1 （IBM模型2的EM算法的收敛性）</h6><p>我们使用$t^{(s)}$和$q^{(s)}$来指代EM算法的$s$次迭代之后的参数估计，并且$t^{(0)}$和$q^{(0)}$来指代初始参数估计。 那么对于任何$s\ge 1$，我们都有</p>
<script type="math/tex; mode=display">
\begin{eqnarray*}
L(t^{(s)},q^{(s)})\ge 
L(t^{(s-1)},q^{(s-1)}) \tag 4
\end{eqnarray*}</script><p>此外，在温和的条件下，当$s\to \infty$，参数估计$(t^{(s)},q^{(s)})$收敛于对数似然函数的局部最优值。</p>
<p>​    在本课程的后面部分，我们将更详细地考虑EM算法：我们将展示它可以应用于NLP中的各种模型，我们将更详细地描述它的理论属性。 目前，这种收敛定理是算法最重要的属性。<br>​     公式4指出对数似然是严格不递减的：在EM算法的每次迭代中，它不会减少。 然而，这并不排除相当无趣的情况，例如对所有$s$</p>
<script type="math/tex; mode=display">
L(t^{(s)},q^{(s)})= 
L(t^{(s-1)},q^{(s-1)})</script><p>第二个条件表明该方法实际上收敛于对数似然函数的局部最优。<br>    该结论的一个重要结果如下：IBM模型2的EM算法可以收敛到不同的参数估计，这取决于初始参数值$t^{(0)}$和$q^{(0)}$。 这是因为算法可以根据其初始点收敛到不同的局部最优值。 实际上，这意味着在初始化中经常需要注意（即，选择初始参数值）。</p>
<h3 id="7-使用IBM-Model-1进行初始化"><a href="#7-使用IBM-Model-1进行初始化" class="headerlink" title="7.使用IBM Model 1进行初始化"></a>7.使用IBM Model 1进行初始化</h3><p>如前一节所述，IBM模型2的EM算法可能对初始值敏感：根据初始值，它可能会收敛到对数似然函数的不同局部最优值。<br>    因此，在实际中，选择良好的参数初始化是很重要的。 一种非常常见的方法是使用IBM模型1。 我们将在本节中描述IBM模型1和基于IBM模型1的初始化方法。<br>    回想一下，在IBM模型2中，我们有参数</p>
<script type="math/tex; mode=display">
q(j|i,l,m)</script><p>这被解释为法语单词$f_i$与英语单词$e_j$对齐的条件概率，给定法语长度$m$和英语长度$l$。 在IBM模型1中，我们简单地假设对于所有$i,j,l,m$，</p>
<script type="math/tex; mode=display">
q(j|i,l,m) =\frac 1 {l+1}</script><p>因此，在所有$l + 1$个可能的英语单词上存在均匀概率分布（回想起英语句子是$e_1…e_l$，并且还有可能$j=0$，表明法语单词与$e_0 =\text{NULL}$对齐）。 这导致以下定义：</p>
<h6 id="定义-3（IBM模型1）"><a href="#定义-3（IBM模型1）" class="headerlink" title="定义 3（IBM模型1）"></a>定义 3（IBM模型1）</h6><p>IBM-M1模型由英语单词的有限集合$\mathcal E$，法语单词集合$\mathcal F$，以及指定法语和英语句子的最大长度的整数$M$和$L$组成。 该模型的参数如下：</p>
<ul>
<li>$t(f|e)$，对任何$f\in \mathcal F,e \in \mathcal E \cup \{\text{NULL}\}$。 参数$t(f|e)$可以解释为由英语单词$e$生成法语单词$f$的条件概率。</li>
</ul>
<p>给定这些定义，对于任何英语句子$e_1…e_l$，其中每个$e_j \in \mathcal E$，对于每个长度$m$，我们定义关于法语句子$f_1…f_m$以及对其变量$a_1…a_m$的条件概率为</p>
<script type="math/tex; mode=display">
p(f_1...f_m,a_l...a_m| e_1...e_l,m)
=\prod_{i=1}^m \frac 1 {(l+1)}t(f_i|e_{a_i})
=\frac 1 {(l+1)^m }\prod_{i=1}^m t(f_i|e_{a_i})</script><p>这里我们定义$e_0$为单词$\text{NULL}$。</p>
<p>​    可以使用EM算法估计IBM模型1的参数，该算法与IBM模型2的算法非常相似。算法如图4所示。对IBM模型2算法的唯一变化来自更换</p>
<script type="math/tex; mode=display">
\delta(k,i,j) =\frac{q(j|i,l_k,m_k)t(f_i^{(k)}|e_j^{(k)})}
{\sum_{j=0}^{l_k}q(j|i,l_k,m_k)t(f_i^{(k)}|e_j^{(k)})}</script><p>为</p>
<script type="math/tex; mode=display">
\delta(k,i,j) =\frac{\frac 1{(l^{(k)}+1)}t(f_i^{(k)}|e_j^{(k)})}
{\sum_{j=0}^{l_k}\frac 1{(l^{(k)}+1)}t(f_i^{(k)}|e_j^{(k)})}
= \frac{t(f_i^{(k)}|e_j^{(k)})}
{\sum_{j=0}^{l_k}t(f_i^{(k)}|e_j^{(k)})}</script><p>反映了我们在模型1中有</p>
<script type="math/tex; mode=display">
q(j|i,l_k,m_k) =\frac 1{(l^{(k)}+1)}</script><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2019022003.jpg?raw=true" alt=""></p>
<p>​    IBM模型1的一个关键性质如下：</p>
<h6 id="命题-1"><a href="#命题-1" class="headerlink" title="命题 1"></a>命题 1</h6><p>在温和的条件下，图4中的EM算法收敛于IBM模型1下的对数似然函数的全局最优解。</p>
<p>​    因此，对于IBM模型1，我们可以保证收敛到对数似然函数的全局最优解。 因此，无论如何初始化，EM算法都会收敛到相同的值。 这表明了以下用于训练IBM模型2参数的过程：</p>
<ol>
<li>使用图4中的算法，使用IBM模型1的EM算法估算参数$t$。</li>
<li>使用图2中的算法估算IBM模型2的参数。要初始化此模型，请使用：<ul>
<li>1）在IBM模型1中步骤1中估计的参数$t(f|e)$来初始化参数$t$。</li>
<li>2）随机值来初始化$q(j|i,l,m)$。</li>
</ul>
</li>
</ol>
<p>​    直观地说，如果IBM模型1得到对参数$t$的合理估计，则该方法通常应该对IBM模型2执行得更好。实际上通常就是这种情况。</p>
<h2 id="本讲测验题"><a href="#本讲测验题" class="headerlink" title="本讲测验题"></a>本讲测验题</h2><h3 id="Coursera部分"><a href="#Coursera部分" class="headerlink" title="Coursera部分"></a>Coursera部分</h3><h4 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042701.jpg?raw=true" alt=""></p>
<p>因为</p>
<script type="math/tex; mode=display">
l = 5,m=3</script><p>所以结果为</p>
<script type="math/tex; mode=display">
(l+1)^m=6^3</script><p>选c</p>
<h4 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042702.jpg?raw=true" alt=""></p>
<p>注意</p>
<script type="math/tex; mode=display">
l=3,m=3</script><p>所以由公式可得</p>
<script type="math/tex; mode=display">
p(a | e, m)=\frac{1}{(l+1)^{m}}=\frac 1 {64}</script><h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042703.jpg?raw=true" alt=""></p>
<p>注意公式</p>
<script type="math/tex; mode=display">
p(f | a, e, m)=\prod_{j=1}^{m} t\left(f_{j} | e_{a_{j}}\right)</script><p>所以</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(f | a, e, m)
&=t(\text { abarks } | \text { barks })
\times t(\operatorname{adog} | \operatorname{dog}) \times t(\text { athe } | \text { the })\\
&=0.1\times 0.2\times 0.5\\
&=0.01
\end{aligned}</script><h4 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042704.jpg?raw=true" alt=""></p>
<script type="math/tex; mode=display">
\begin{aligned}
p(a | e, m)
&=\prod_{j=1}^{m} q\left(a_{j} | j, l, m\right)\\
&= q\left(3 | 1, 3, 3\right) \times q\left(2 | 2, 3, 3\right)
\times \times q\left(1 | 3, 3, 3\right)\\
&=0.6\times 0.9\times 0.2\\
&=0.108
\end{aligned}</script><h4 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042705.jpg?raw=true" alt=""></p>
<script type="math/tex; mode=display">
\begin{aligned}
q(0 | 1,3,3) \times t\left(f_{1} | e_{0}\right)&=0.1\times 0.1=0.01\\
q(1 | 1,3,3) \times t\left(f_{1} | e_{1}\right)&=0.4\times 0.2=0.08\\
q(2 | 1,3,3) \times t\left(f_{1} | e_{2}\right)&=0.2\times 0.5=0.1\\
q(3 | 1,3,3) \times t\left(f_{1} | e_{3}\right)&=0.3\times 0.2=0.06
\end{aligned}</script><p>所以</p>
<script type="math/tex; mode=display">
a_{1}^{*}=2</script><h4 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042706.jpg?raw=true" alt=""></p>
<script type="math/tex; mode=display">
\begin{aligned}
t_{\mathrm{ML}}(\mathrm{Le} | \text {the})&=\frac{1}{1}=1 \\
t_{\mathrm{ML}}(\mathrm{Le} | \mathrm{And})&=\frac 0 1 = 0 \\
t_{\mathrm{ML}}(\text {mis } | \text { implemented})&=\frac {1}{3}=0.333 \\
t_{\mathrm{ML}}(\mathrm{en} | \text { implemented})&= \frac 13 =0.333\\
t_{\mathrm{ML}}(\text {application } | \text { implemented})&=\frac 1 3 =0.333\\
t_{\mathrm{ML}}(\text {application } | \mathrm{NULL})&=\frac 0 1 =0
\end{aligned}</script><h4 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h4><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/Michael%20Collins%20NLP/Lecture%207/2020042707.jpg?raw=true" alt=""></p>
<script type="math/tex; mode=display">
\begin{aligned}
\delta(1, 1, 3)&=\frac{q\left(3 | 1, l_{1}, m_{1}\right) t\left(f_{1}^{(1)} | e_{3}^{(1)}\right)}{\sum_{j=0}^{l_{k}} q\left(j | i, l_{k}, m_{k}\right) t\left(f_{i}^{(k)} | e_{j}^{(k)}\right)}\\
&=\frac{0.1\times 0.3}{0.1\times 0.2+0.4\times 0.1 + 0.4\times 0.4+0.1\times 0.3}\\
&=0.12
\end{aligned}</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Doraemonzzz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.doraemonzzz.com/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/">http://www.doraemonzzz.com/2019/03/01/Michael%20Collins%20NLP%20Lecture%207/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.doraemonzzz.com" target="_blank">Doraemonzzz</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Michael-Collins-NLP/">Michael Collins NLP</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/03/01/Michael%20Collins%20NLP%20Lecture%208/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Michael Collins NLP Lecture 8</div></div></a></div><div class="next-post pull-right"><a href="/2019/03/01/CS229%20%E8%80%81%E7%89%88%E4%BD%9C%E4%B8%9A1/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CS229 老版作业1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/04/08/Michael Collins NLP Homework 1/" title="Michael Collins NLP Homework 1"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-08</div><div class="title">Michael Collins NLP Homework 1</div></div></a></div><div><a href="/2020/05/18/Michael Collins NLP Homework 4/" title="Michael Collins NLP Homework 4"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-18</div><div class="title">Michael Collins NLP Homework 4</div></div></a></div><div><a href="/2020/05/07/Michael Collins NLP Homework 3/" title="Michael Collins NLP Homework 3"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-07</div><div class="title">Michael Collins NLP Homework 3</div></div></a></div><div><a href="/2020/04/21/Michael Collins NLP Homework 2/" title="Michael Collins NLP Homework 2"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-21</div><div class="title">Michael Collins NLP Homework 2</div></div></a></div><div><a href="/2019/01/24/Michael Collins NLP Lecture 1/" title="Michael Collins NLP Lecture 1"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-01-24</div><div class="title">Michael Collins NLP Lecture 1</div></div></a></div><div><a href="/2019/03/03/Michael Collins NLP Lecture 11/" title="Michael Collins NLP Lecture 11"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-03</div><div class="title">Michael Collins NLP Lecture 11</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC8zNDcxOS8xMTI1Ng=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "/img/loading.gif" data-lazy-src="https://github.com/Doraemonzzz/md-photo/blob/master/%E5%A4%B4%E5%83%8F.jpg?raw=true" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Doraemonzzz</div><div class="author-info__description">个人博客，主要记录有关机器学习，数学以及计算机科学的笔记</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">621</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Doraemonzzz"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Doraemonzzz" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/doraemon_zzz@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/291079982" target="_blank" title="Bilibili"><i class="iconfont icon-bilibili"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">暂无公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%EF%BC%9AIBM%E6%A8%A1%E5%9E%8B1%E5%92%8C2"><span class="toc-number">1.</span> <span class="toc-text">Chapter 5 统计机器翻译：IBM模型1和2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%99%AA%E5%A3%B0%E9%80%9A%E9%81%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">2.噪声通道方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IBM%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">3.IBM模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AF%B9%E9%BD%90%EF%BC%88Alignments%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 对齐（Alignments）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AF%B9%E9%BD%90%E6%A8%A1%E5%9E%8B%EF%BC%9AIBM%E6%A8%A1%E5%9E%8B2"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 对齐模型：IBM模型2</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1%EF%BC%88IBM%E6%A8%A1%E5%9E%8B2%EF%BC%89"><span class="toc-number">1.3.2.0.1.</span> <span class="toc-text">定义 1（IBM模型2）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-IBM%E6%A8%A1%E5%9E%8B2%E4%B8%AD%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%81%87%E8%AE%BE"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 IBM模型2中的独立假设</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8IBM%E6%A8%A1%E5%9E%8B2"><span class="toc-number">1.4.</span> <span class="toc-text">4.应用IBM模型2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-number">1.5.</span> <span class="toc-text">5.参数估计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%85%B7%E6%9C%89%E5%AE%8C%E5%85%A8%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 具有完全观测数据的参数估计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E9%83%A8%E5%88%86%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 部分观测数据的参数估计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%89%E5%85%B3EM%E7%AE%97%E6%B3%95%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%EF%BC%9A%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1"><span class="toc-number">1.6.</span> <span class="toc-text">6. 有关EM算法的更多信息：最大似然估计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2-%EF%BC%88IBM%E6%A8%A1%E5%9E%8B2%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%88ML%EF%BC%89%EF%BC%89"><span class="toc-number">1.6.0.0.1.</span> <span class="toc-text">定义 2 （IBM模型2的最大似然估计（ML））</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-1-%EF%BC%88IBM%E6%A8%A1%E5%9E%8B2%E7%9A%84EM%E7%AE%97%E6%B3%95%E7%9A%84%E6%94%B6%E6%95%9B%E6%80%A7%EF%BC%89"><span class="toc-number">1.6.0.0.2.</span> <span class="toc-text">定理 1 （IBM模型2的EM算法的收敛性）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BD%BF%E7%94%A8IBM-Model-1%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">7.使用IBM Model 1进行初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3%EF%BC%88IBM%E6%A8%A1%E5%9E%8B1%EF%BC%89"><span class="toc-number">1.7.0.0.1.</span> <span class="toc-text">定义 3（IBM模型1）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%BD%E9%A2%98-1"><span class="toc-number">1.7.0.0.2.</span> <span class="toc-text">命题 1</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E8%AE%B2%E6%B5%8B%E9%AA%8C%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">本讲测验题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Coursera%E9%83%A8%E5%88%86"><span class="toc-number">2.1.</span> <span class="toc-text">Coursera部分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4"><span class="toc-number">2.1.4.</span> <span class="toc-text">4.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5"><span class="toc-number">2.1.5.</span> <span class="toc-text">5.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6"><span class="toc-number">2.1.6.</span> <span class="toc-text">6.</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7"><span class="toc-number">2.1.7.</span> <span class="toc-text">7.</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/24/2021-6-24-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-4ProxyServer/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 4:ProxyServer"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 4:ProxyServer"/></a><div class="content"><a class="title" href="/2021/06/24/2021-6-24-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-4ProxyServer/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 4:ProxyServer">计算机网络——自顶向下方法（第七版）Socket Programming Assignment 4:ProxyServer</a><time datetime="2021-06-24T15:59:00.000Z" title="发表于 2021-06-24 23:59:00">2021-06-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/22/2021-6-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-3SMTP/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 3:SMTP"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 3:SMTP"/></a><div class="content"><a class="title" href="/2021/06/22/2021-6-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-3SMTP/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 3:SMTP">计算机网络——自顶向下方法（第七版）Socket Programming Assignment 3:SMTP</a><time datetime="2021-06-22T15:51:00.000Z" title="发表于 2021-06-22 23:51:00">2021-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/22/2021-6-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-2UDPpinger/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 2:UDPpinger"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 2:UDPpinger"/></a><div class="content"><a class="title" href="/2021/06/22/2021-6-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-2UDPpinger/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 2:UDPpinger">计算机网络——自顶向下方法（第七版）Socket Programming Assignment 2:UDPpinger</a><time datetime="2021-06-22T15:21:00.000Z" title="发表于 2021-06-22 23:21:00">2021-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/22/2021-6-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-1WebServer/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 1:WebServer"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 1:WebServer"/></a><div class="content"><a class="title" href="/2021/06/22/2021-6-22-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%88%E7%AC%AC%E4%B8%83%E7%89%88%EF%BC%89Socket-Programming-Assignment-1WebServer/" title="计算机网络——自顶向下方法（第七版）Socket Programming Assignment 1:WebServer">计算机网络——自顶向下方法（第七版）Socket Programming Assignment 1:WebServer</a><time datetime="2021-06-22T14:44:00.000Z" title="发表于 2021-06-22 22:44:00">2021-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/21/2021-6-21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A(SICP)-%E7%AC%AC4%E7%AB%A0-%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90-Part4/" title="计算机程序的构造和解释(SICP) 第4章 习题解析 Part4"><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机程序的构造和解释(SICP) 第4章 习题解析 Part4"/></a><div class="content"><a class="title" href="/2021/06/21/2021-6-21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A(SICP)-%E7%AC%AC4%E7%AB%A0-%E4%B9%A0%E9%A2%98%E8%A7%A3%E6%9E%90-Part4/" title="计算机程序的构造和解释(SICP) 第4章 习题解析 Part4">计算机程序的构造和解释(SICP) 第4章 习题解析 Part4</a><time datetime="2021-06-21T01:54:00.000Z" title="发表于 2021-06-21 09:54:00">2021-06-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2021 By Doraemonzzz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.25
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'IpnmxCW9CvYWIXbol5QXsegX-MdYXbMMI',
      appKey: 'w57DVCdbxcyB1TYYagMIMJIU',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Valine' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>